unchanged:
--- SkyX-0.4/SkyX/Include/AtmosphereManager.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/AtmosphereManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -148,11 +148,14 @@
 		const Ogre::Vector3 getColorAt(const Ogre::Vector3& Direction) const;
 
 		/** Update atmoshpere
-		    @param NewOptions Update only the differences between actual parameters and new ones.
-			@param ForceToUpdateAll Forces to upload all current parameters to skyx material.
+        @param NewOptions Update only the differences between actual
+        parameters and new ones.
+      @param ForceToUpdateAll Forces to upload all current
+      parameters to skyx material.
 			@remarks Current options parameters are updated if needed.
 		 */
-		void _update(const Options& NewOptions, const bool& ForceToUpdateAll = false);
+    void _update(const Options& NewOptions,
+                 const bool& ForceToUpdateAll = false);
 	
 	private:
 		/** Shader scale funtion 
@@ -160,13 +163,13 @@
 			@param uScaleDepth Scale Depth
 			@return Scale
 		 */
-		const float _scale(const float& cos, const float& uScaleDepth) const;
-
-		/// Our options
-		Options mOptions;
+    float _scale(const float& cos, const float& uScaleDepth) const;
 
 		/// SkyX parent pointer
 		SkyX *mSkyX;
+
+    /// Our options
+    Options mOptions;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/BasicController.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/BasicController.h	2013-07-23 19:51:21.000000000 -0400
@@ -36,18 +36,22 @@
 	{
 	public:
 	    /** Constructor
-		    @param deleteBySkyX true to automatically destroy the controller by SkyX, false otherwise
+          @param deleteBySkyX true to automatically destroy the controller by
+          SkyX, false otherwise
 		 */
 		BasicController(const bool& deleteBySkyX = true);
 
 		/** Update controller
-		    @param simDeltaTime Simulation delta time (It's not the time since last frame, it's the delta simulation time, one
-								time the time since last frame has been multiplied by the time multiplier)
+          @param simDeltaTime Simulation delta time (It's not the time since
+          last frame, it's the delta simulation time, one
+          time the time since last frame has been multiplied by the time
+          multiplier)
 		 */
 		void update(const Ogre::Real& simDeltaTime);
 
 		/** Set time
-		    @param t Time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
+          @param t Time, where x = time in [0, 24]h range,
+          y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
 		 */
 		inline void setTime(const Ogre::Vector3& t)
 		{
@@ -56,7 +60,8 @@
 		}
 
 		/** Get time
-		    @return Current time, where x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
+          @return Current time, where x = time in [0, 24]h range,
+          y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
 		 */
 		inline const Ogre::Vector3& getTime() const
 		{
@@ -64,7 +69,7 @@
 		}
 
 		/** Set eastn direction
-		    @param ed East direction, in X,Z world coords (must be normalized)
+          @param ed East direction, in X,Y world coords (must be normalized)
 		 */
 		inline void setEastDirection(const Ogre::Vector2& ed)
 		{
@@ -73,7 +78,7 @@
 		}
 
 		/** Get east direction
-		    @return Current east direction, in X,Z world coords
+          @return Current east direction, in X,Y world coords
 		 */
 		inline const Ogre::Vector2& getEastDirection() const
 		{
@@ -97,7 +102,8 @@
 		}
 
 		/** Set moon phase
-		    @param mp Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon
+          @param mp Moon phase in [-1,1] range, where -1 means fully
+          covered Moon, 0 clear Moon and 1 fully covered Moon
 		 */
 		inline void setMoonPhase(const Ogre::Real& mp)
 		{
@@ -105,7 +111,8 @@
 		}
 
 		/** Get moon phase
-		    @return Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon
+          @return Moon phase in [-1,1] range, where -1 means
+          fully covered Moon, 0 clear Moon and 1 fully covered Moon
 		 */
 		inline Ogre::Real getMoonPhase()
 		{
@@ -113,15 +120,19 @@
 		}
 
 	private:
-		/// Time information: x = time in [0, 24]h range, y = sunrise hour in [0, 24]h range, z = sunset hour in [0, 24] range
+      /// Time information: x = time in [0, 24]h range, y = sunrise
+      /// hour in [0, 24]h range, z = sunset hour in [0, 24] range
 		Ogre::Vector3 mTime;
-		/// East direction (in X,Z world coords)
-		Ogre::Vector2 mEastDirection;
 
 		/// Sun direction
 		Ogre::Vector3 mSunDirection;
+
 		/// Moon direction
 		Ogre::Vector3 mMoonDirection;
+
+      /// East direction (in X,Z world coords)
+      Ogre::Vector2 mEastDirection;
+
 		/// Moon phase
 		Ogre::Real mMoonPhase;
 	};
unchanged:
--- SkyX-0.4/SkyX/Include/CloudsManager.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/CloudsManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,7 @@
 #ifndef _SkyX_CloudsManager_H_
 #define _SkyX_CloudsManager_H_
 
+#include <vector>
 #include "Prerequisites.h"
 
 #include "ColorGradient.h"
@@ -207,18 +208,18 @@
 		 */
 		void _updatePassParameters();
 
+    /// SkyX parent pointer
+    SkyX *mSkyX;
+
 		/// Cloud layer options
 		Options mOptions;
 
-		/// Ambient and Sun color gradients
-		ColorGradient mAmbientGradient;
-		ColorGradient mSunGradient;
-
 		/// Cloud layer pass
 		Ogre::Pass *mCloudLayerPass;
 
-		/// SkyX parent pointer
-		SkyX *mSkyX;
+    /// Ambient and Sun color gradients
+    ColorGradient mAmbientGradient;
+    ColorGradient mSunGradient;
 	};
 
     class DllExport CloudsManager 
@@ -273,13 +274,14 @@
 		}
 
 	private:
+    /// SkyX parent pointer
+    SkyX *mSkyX;
+
 		/// Cloud layers std::vector
 		std::vector<CloudLayer*> mCloudLayers;
+
 		/// Cloud layers iterator
 		std::vector<CloudLayer*>::iterator CloudLayersIt;
-
-		/// SkyX parent pointer
-		SkyX *mSkyX;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/ColorGradient.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/ColorGradient.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,9 @@
 #ifndef _SkyX_ColorGradient_H_
 #define _SkyX_ColorGradient_H_
 
+#include <vector>
+#include <utility>
+
 #include "Prerequisites.h"
 
 namespace SkyX
@@ -72,7 +75,7 @@
 		/** Check bounds
 		    @return false if the Color gradient is mal-formed
 		 */
-		const bool _checkBounds() const;
+    bool _checkBounds() const;
 
 		/// Mal formed color gradient?
 		bool mMalFormed;
unchanged:
--- SkyX-0.4/SkyX/Include/Controller.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/Controller.h	2013-07-23 19:51:21.000000000 -0400
@@ -34,9 +34,10 @@
 	{
 	public:
 	    /** Constructor
-		    @param deleteBySkyX true to automatically destroy the controller by SkyX, false otherwise
+        @param deleteBySkyX true to automatically destroy the
+        controller by SkyX, false otherwise
 		 */
-		inline Controller(const bool& deleteBySkyX)
+    explicit inline Controller(const bool& deleteBySkyX)
 			: mDeleteBySkyX(deleteBySkyX)
 		{
 		}
@@ -46,10 +47,12 @@
 		inline virtual ~Controller(){}
 
 		/** Update controller
-		    @param simDeltaTime Simulation delta time (It's not the time since last frame, it's the delta simulation time, one
-								time the time since last frame has been multiplied by the time multiplier)
+        @param simDeltaTime Simulation delta time (It's not the time
+        since last frame, it's the delta simulation time, one
+        time the time since last frame has been multiplied by the
+        time multiplier)
 		 */
-		inline virtual void update(const Ogre::Real& simDeltaTime){}
+    inline virtual void update(const Ogre::Real& /*simDeltaTime*/) {}
 
 		/** Get sun direction
 		    @return Sun direction, the Earth-to-Sun direction
@@ -62,7 +65,8 @@
 		virtual Ogre::Vector3 getMoonDirection() = 0;
 
 		/** Get moon phase
-		    @return Moon phase in [-1,1] range, where -1 means fully covered Moon, 0 clear Moon and 1 fully covered Moon
+        @return Moon phase in [-1,1] range, where -1 means fully covered
+        Moon, 0 clear Moon and 1 fully covered Moon
 		 */
 		virtual Ogre::Real getMoonPhase() = 0;
 
unchanged:
--- SkyX-0.4/SkyX/Include/GPUManager.h	2012-09-17 18:08:56.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/GPUManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,8 @@
 #ifndef _SkyX_GPUManager_H_
 #define _SkyX_GPUManager_H_
 
+#include <vector>
+
 #include "Prerequisites.h"
 
 namespace SkyX
@@ -54,10 +56,13 @@
 
 		/** Add ground pass (Use for atmospheric scattering effect on the terrain)
 		    @param GroundPass Ground pass
-			@param AtmosphereRaidus Atmosphere radius (typically far carmera clip plane)
+      @param AtmosphereRaidus Atmosphere radius (typically far carmera clip
+      plane)
 			@param SBT Scene blend type
 		 */
-		void addGroundPass(Ogre::Pass* GroundPass, const Ogre::Real& AtmosphereRadius, const Ogre::SceneBlendType& SBT = Ogre::SBT_ADD);
+    void addGroundPass(Ogre::Pass* GroundPass,
+        const Ogre::Real& AtmosphereRadius,
+        const Ogre::SceneBlendType& SBT = Ogre::SBT_ADD);
 
 		/** Set gpu program int parameter
 		    @param GpuP Gpu program type (Vertex/Fragment)
@@ -65,7 +70,9 @@
 			@param Value value
 			@param UpdateGroundPasses true to update ground passes
 		 */
-		void setGpuProgramParameter(const GpuProgram &GpuP, const Ogre::String &Name, const int &Value, const bool& UpdateGroundPasses = true);
+    void setGpuProgramParameter(const GpuProgram &GpuP,
+        const Ogre::String &Name, const int &Value,
+        const bool& UpdateGroundPasses = true);
 
 		/** Set gpu program Ogre::Real parameter
 		    @param GpuP Gpu program type (Vertex/Fragment)
@@ -73,7 +80,9 @@
 			@param Value value
 			@param UpdateGroundPasses true to update ground passes
 		 */
-		void setGpuProgramParameter(const GpuProgram &GpuP, const Ogre::String &Name, const Ogre::Real &Value, const bool& UpdateGroundPasses = true);
+    void setGpuProgramParameter(const GpuProgram &GpuP,
+        const Ogre::String &Name, const Ogre::Real &Value,
+        const bool& UpdateGroundPasses = true);
 
 		/** Set gpu program Ogre::Vector2 parameter
 		    @param GpuP Gpu program type (Vertex/Fragment)
@@ -81,7 +90,9 @@
 			@param Value value
 			@param UpdateGroundPasses true to update ground passes
 		 */
-		void setGpuProgramParameter(const GpuProgram &GpuP, const Ogre::String &Name, const Ogre::Vector2 &Value, const bool& UpdateGroundPasses = true); 
+    void setGpuProgramParameter(const GpuProgram &GpuP,
+        const Ogre::String &Name, const Ogre::Vector2 &Value,
+        const bool& UpdateGroundPasses = true);
 
 		/** Set gpu program Ogre::Vector3 parameter
 		    @param GpuP Gpu program type (Vertex/Fragment)
@@ -89,7 +100,9 @@
 			@param Value value
 			@param UpdateGroundPasses true to update ground passes
 		 */
-		void setGpuProgramParameter(const GpuProgram &GpuP, const Ogre::String &Name, const Ogre::Vector3 &Value, const bool& UpdateGroundPasses = true); 
+    void setGpuProgramParameter(const GpuProgram &GpuP,
+        const Ogre::String &Name, const Ogre::Vector3 &Value,
+        const bool& UpdateGroundPasses = true);
 
 		/** Get skydome material name
 		    @return Skydome material name
@@ -114,16 +127,25 @@
 		 */
 		inline void _notifySkydomeMaterialChanged()
 		{
-			mSkydomeMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName(getSkydomeMaterialName()));
+      mSkydomeMaterial = static_cast<Ogre::MaterialPtr>(
+          Ogre::MaterialManager::getSingleton().getByName(
+            getSkydomeMaterialName()));
 
 			if (mSkydomeMaterial.isNull())
 			{
-				SkyXLOG("Error in SkyX::GPUManager: '" + getSkydomeMaterialName() + "' material not found");
+        SkyXLOG("Error in SkyX::GPUManager: '" +
+            getSkydomeMaterialName() + "' material not found");
 				return;
 			}
 		}
 		
 	private:
+    /// SkyX parent pointer
+    SkyX *mSkyX;
+
+    /// Ground pass vector
+    std::vector<Ogre::Pass*> mGroundPasses;
+
 		/** Set texture HW gamma correction
 		    @param n Texture name
 			@param g True to enable gamma correction, false to disable it
@@ -132,11 +154,6 @@
 
 		/// Skydome material
 		Ogre::MaterialPtr mSkydomeMaterial;
-		/// Ground pass vector
-		std::vector<Ogre::Pass*> mGroundPasses;
-
-		/// SkyX parent pointer
-		SkyX *mSkyX;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/MeshManager.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/MeshManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -162,17 +162,25 @@
 		}
 
 		/** Set under-horizon rendering params
-		    @remarks In an ideal situation, you only must see the avobe horizon sky due to the fact that the terrain/water
+      @remarks In an ideal situation, you only must see the avobe
+      horizon sky due to the fact that the terrain/water
 			         must be 'infinite' and the under-horizont sky part is hide.
-					 But, infinite terrain/water is not always implemented in games and 3d apps in general, so... in order to
-					 get a good-looking sky, SkyX provides an approach to render realistic under-horizont sky.
-			@param UnderHorizonCircles Number of circles of SkyX::MeshManager::mCircles reserved for the under-horizont geometry part,
+      But, infinite terrain/water is not always implemented in games and
+      3d apps in general, so... in order to get a good-looking sky, SkyX
+      provides an approach to render realistic under-horizont sky.
+      @param UnderHorizonCircles Number of circles of
+      SkyX::MeshManager::mCircles reserved for the under-horizont geometry part,
 				   0 means not under-horizon rendering
 			@param UnderHorizonFading true/false to fade or not the under-horizon sky
-			@param UnderHorizonFadingExponent Exponent of the fading, pow(vertex_angle, exp), 1=linear
-			@param UnderHorizonFadingMultiplier Fading multiplier, opacity = saturate(pow(opacity,fading_exp)*fading_multiplier)
-		 */
-		void setUnderHorizonParams(const int& UnderHorizonCircles = 15, const bool& UnderHorizonFading = true, const Ogre::Real& UnderHorizonFadingExponent = 1, const Ogre::Real& UnderHorizonFadingMultiplier = 2);
+      @param UnderHorizonFadingExponent Exponent of the fading,
+      pow(vertex_angle, exp), 1=linear
+      @param UnderHorizonFadingMultiplier Fading multiplier,
+      opacity = saturate(pow(opacity,fading_exp)*fading_multiplier)
+     */
+    void setUnderHorizonParams(const int& UnderHorizonCircles = 15,
+        const bool& UnderHorizonFading = true,
+        const Ogre::Real& UnderHorizonFadingExponent = 1,
+        const Ogre::Real& UnderHorizonFadingMultiplier = 2);
 
 		/** Get under-horizon circles
 		    @return Under-horizon circles
@@ -220,18 +228,22 @@
 		    @param c Camera
 		    @return Skydome radius relative to the given camera
 		 */
-		const float getSkydomeRadius(Ogre::Camera* c) const;
+    float getSkydomeRadius(Ogre::Camera* c) const;
 
 	private:
 		/** Create geometry
 		 */
 		void _createGeometry();
 
+    /// Main SkyX pointer
+    SkyX* mSkyX;
+
 		/// Has been create() already called?
 		bool mCreated;
 
 		/// Ogre::MeshPtr
         Ogre::MeshPtr mMesh;
+
         /// Ogre::Submesh pointer
         Ogre::SubMesh *mSubMesh;
         /// Ogre::Entity pointer
@@ -239,37 +251,36 @@
 
         /// Vertex buffer
         Ogre::HardwareVertexBufferSharedPtr mVertexBuffer;
-        /// Index buffer
-        Ogre::HardwareIndexBufferSharedPtr  mIndexBuffer;
 
 		/// Vertices
 		VERTEX* mVertices;
 
-		/// Circles
-		int mCircles;
+    /// Index buffer
+    Ogre::HardwareIndexBufferSharedPtr  mIndexBuffer;
+
+    /// Ogre::SceneNode pointer
+    Ogre::SceneNode* mSceneNode;
+
 		/// Steps
 		int mSteps;
 
+    /// Circles
+    int mCircles;
 		/// Under-horizon rendering
 		int mUnderHorizonCircles;
 		/// Under-horizon fading
 		bool mUnderHorizonFading;
 		/// Under-horizon exponent fading (1=linear fading)
 		Ogre::Real mUnderHorizonFadingExponent;
-		/// Under-horizon fading multiplier: opacity = saturate(pow(opacity,fading_exp)*fading_multiplier)
+    /// Under-horizon fading multiplier:
+    /// opacity = saturate(pow(opacity,fading_exp)*fading_multiplier)
 		Ogre::Real mUnderHorizonFadingMultiplier;
 
 		/// Radius multiplier
 		Ogre::Real mRadiusMultiplier;
 
-		/// Ogre::SceneNode pointer
-		Ogre::SceneNode* mSceneNode;
-
         /// Material name
         Ogre::String mMaterialName;
-
-		/// Main SkyX pointer
-		SkyX* mSkyX;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/MoonManager.h	2012-03-08 20:29:38.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/MoonManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -132,12 +132,27 @@
 			return mCreated;
 		}
 
+    void setVisible(bool _visible)
+    {
+      this->mVisible = _visible;
+      this->mMoonSceneNode->setVisible(_visible);
+    }
+
+    void setEnabled(bool _enabled)
+    {
+      bool visible = _enabled ? mVisible : false;
+      this->mMoonSceneNode->setVisible(visible);
+    }
+
 	private:
 		/** Update moon bounds
 		    @param c Camera
 	     */
 		void _updateMoonBounds(Ogre::Camera* c);
 
+    /// SkyX parent pointer
+    SkyX *mSkyX;
+
 		/// Moon billboard
 		Ogre::BillboardSet* mMoonBillboard;
 		/// Moon scene node
@@ -156,8 +171,8 @@
 		/// Moon material
 		Ogre::MaterialPtr mMoonMaterial;
 
-		/// SkyX parent pointer
-		SkyX *mSkyX;
+    /// True if visible
+    bool mVisible;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/Prerequisites.h	2013-02-01 23:08:56.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/Prerequisites.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,11 +24,15 @@
 #ifndef _SkyX_Prerequisites_H_
 #define _SkyX_Prerequisites_H_
 
-#pragma warning (disable:4244) // conversion from 'xxx' to 'yyy', possible loss of data
-#pragma warning (disable:4355) // 'this' : used in base member initializer list
+#ifdef _MSC_VER
+  // conversion from 'xxx' to 'yyy', possible loss of data
+  #pragma warning(disable:4244)
+  // 'this' : used in base member initializer list
+  #pragma warning(disable:4355)
+#endif
 
 /// Include external headers
-#include <Ogre.h>
+#include <OGRE/Ogre.h>
 
 /// Define the dll export qualifier if compiling for Windows
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
@@ -42,13 +46,20 @@
 #endif
 
 /// Log macro
-#define SkyXLOG(msg) Ogre::LogManager::getSingleton().logMessage("[SkyX] " + Ogre::String(msg));
+#define SkyXLOG(msg) Ogre::LogManager::getSingleton().logMessage("[SkyX] " + \
+    Ogre::String(msg));
 
 /// SkyX defines
 #define SKYX_VERSION_MAJOR 0
-#define SKYX_VERSION_MINOR 4
-#define SKYX_VERSION_PATCH 0
+#define SKYX_VERSION_MINOR 3
+#define SKYX_VERSION_PATCH 1
 
 #define SKYX_RESOURCE_GROUP "SkyX"
 
+template<typename T>
+inline bool equal(const T &_a, const T &_b, const T &_epsilon = 1e-3)
+{
+  return std::fabs(_a - _b) <= _epsilon;
+}
+
 #endif
unchanged:
--- SkyX-0.4/SkyX/Include/SkyX.h	2012-12-27 00:31:56.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/SkyX.h	2013-07-23 19:51:21.000000000 -0400
@@ -57,7 +57,8 @@
 				 For more information have a look to sample projects.
 			     
      */
-	class DllExport SkyX : public Ogre::FrameListener, public Ogre::RenderTargetListener
+  class DllExport SkyX : public Ogre::FrameListener,
+                         public Ogre::RenderTargetListener
 	{
 	public:
 		/** Render queue groups
@@ -65,13 +66,14 @@
 		struct RenderQueueGroups
 		{
 			/** Constructor
-			    @param s Skydome render queue group (Note: Moon = skydome_render_queue+1)
+          @param s Skydome render queue group (Note: Moon =
+          skydome_render_queue+1)
 				@param vc VClouds render queue group
-				@param vclu VClouds lightnings render queue group (when the camera is under the cloud field)
-				@param vclo VClouds lightnings render queue group (when the camera is over the cloud field)
+        @param vcl VClouds lightnings render queue group
 			 */
-			inline RenderQueueGroups(const Ogre::uint8& s, const Ogre::uint8& vc, const Ogre::uint8& vclu, const Ogre::uint8& vclo)
-				: skydome(s), vclouds(vc), vcloudsLightningsUnder(vclu), vcloudsLightningsOver(vclo)
+      inline RenderQueueGroups(const Ogre::uint8& s, const Ogre::uint8& vc,
+                              const Ogre::uint8& vcl)
+        : skydome(s), vclouds(vc), vcloudsLightnings(vcl)
 			{
 			}
 
@@ -79,18 +81,19 @@
 			Ogre::uint8 skydome;
 			/// VClouds render queue group
 			Ogre::uint8 vclouds;
-			/// VClouds lightnings render queue group (when the camera is under the cloud field)
-			Ogre::uint8 vcloudsLightningsUnder;
-			/// VClouds lightnings render queue group (when the camera is over the cloud field)
-			Ogre::uint8 vcloudsLightningsOver;
+      /// VClouds lightnings render queue group
+      Ogre::uint8 vcloudsLightnings;
 		};
 
 		/** Lighting mode enumeration
-		    SkyX is designed for true HDR rendering, but there is a big number of applications
-			which don't use HDR rendering, due to this fact a little exponential tone-mapping 
-			algoritm is applied to SkyX materials if LM_LDR is selected. (See: AtmosphereManager::Options::Exposure)
-			Select LM_HDR if your app is designed for true HDR rendering. In HDR mode, we assume you're ussing a
-			full linear rendering pipeline, so all textures are gamma corrected if needed.
+        SkyX is designed for true HDR rendering, but there is a big
+        number of applications which don't use HDR rendering, due to this
+        fact a little exponential tone-mapping algoritm is applied to SkyX
+        materials if LM_LDR is selected.
+        (See: AtmosphereManager::Options::Exposure)
+        Select LM_HDR if your app is designed for true HDR rendering.
+        In HDR mode, we assume you're ussing a full linear rendering pipeline,
+        so all textures are gamma corrected if needed.
 		 */
 		enum LightingMode
 		{
@@ -121,25 +124,27 @@
         /** Update (to be invoked per frame)
 		    @param timeSinceLastFrame Time elapsed since last frame
             @remarks Invoke this function only one time per frame.
-					 Per-frame update must be performed before per-camera updates through SkyX::notifyCameraRender(...)
-			         Also it's possible to use listeners, making all this process transparent,
-					 just register SkyX in ogre root through Ogre::Root::addFrameListener(...)
+        Per-frame update must be performed before per-camera updates through
+        SkyX::notifyCameraRender(...) Also it's possible to use listeners,
+        making all this process transparent, just register SkyX in ogre root
+        through Ogre::Root::addFrameListener(...)
          */
         void update(const Ogre::Real &timeSinceLastFrame);
 
 		/** Notify camera render (to be invoked per camera and per frame)
 		    @param c Camera
 			@remarks Invoke this method manually before the camera render operation
-				     Per-camera updates must be performed after the per-frame update through SkyX::update(...)
-			         Also it's possible to use listeners, making all this process transparent,
-					 just register SkyX in your render target through Ogre::RenderTarget::addListener(...)
+        Per-camera updates must be performed after the per-frame update
+        through SkyX::update(...) Also it's possible to use listeners,
+        making all this process transparent, just register SkyX in your render
+        target through Ogre::RenderTarget::addListener(...)
 		 */
 		void notifyCameraRender(Ogre::Camera* c);
 
 		/** Is SkyX created?
 		    @return true if yes, false if not
 		 */
-		inline const bool isCreated() const
+    inline bool isCreated() const
 		{
 			return mCreated;
 		}
@@ -159,8 +164,9 @@
 
 		/** Set time multiplier
 		    @param TimeMultiplier Time multiplier
-			@remarks The time multiplier can be a negative number, 0 will disable auto-updating
-			         For setting a custom time of day, check: AtmosphereManager::Options::Time
+      @remarks The time multiplier can be a negative number, 0 will disable
+      auto-updating For setting a custom time of day, check:
+      AtmosphereManager::Options::Time
 		 */
 		inline void setTimeMultiplier(const Ogre::Real& TimeMultiplier)
 		{
@@ -260,11 +266,13 @@
 
 		/** Set lighting mode
 		    @param lm Lighting mode
-			@remarks SkyX is designed for true HDR rendering, but there're a lot of applications
-				     that doesn't use HDR rendering, due to this a little exponential tone-mapping 
-			         algoritm is applied to SkyX materials if LM_LDR is selected. (See: AtmosphereManager::Options::Exposure)
-		         	 Select LM_HDR if your app is designed for true HDR rendering. In HDR mode, we assume you're ussing a
-					 full linear rendering pipeline, so all textures are gamma corrected if needed.
+      @remarks SkyX is designed for true HDR rendering, but there're a lot of
+      applications that doesn't use HDR rendering, due to this a little
+      exponential tone-mapping algoritm is applied to SkyX materials if
+      LM_LDR is selected. (See: AtmosphereManager::Options::Exposure)
+      Select LM_HDR if your app is designed for true HDR rendering.
+      In HDR mode, we assume you're ussing a full linear rendering pipeline,
+      so all textures are gamma corrected if needed.
 		 */
 		void setLightingMode(const LightingMode& lm);
 
@@ -291,9 +299,10 @@
 
 		/** Set infinite camera far clip distance
 		    @param d Infinite camera far clip distance
-			@remarks SkyX needs a finite camera far clip distance in order to builds its geometry. Since Ogre allows infinite far clip
-			         camera distances (camearFarClipDistance = 0) you'll need to manually provide a far clip distance if you're using
-					 an infinite camera far clip distance.
+      @remarks SkyX needs a finite camera far clip distance in order to builds
+      its geometry. Since Ogre allows infinite far clip camera distances
+      (camearFarClipDistance = 0) you'll need to manually provide a far clip
+      distance if you're using an infinite camera far clip distance.
 		 */
 		inline void setInfiniteCameraFarClipDistance(const Ogre::Real& d)
 		{
@@ -343,12 +352,60 @@
 			return mTimeOffset;
 		}
 
+    void setEnabled(bool _enabled)
+    {
+      this->mEnabled = _enabled;
+      this->setMoonEnabled(_enabled);
+      this->setCloudsEnabled(_enabled);
+    }
+
+    inline bool getEnabled()
+    {
+      return this->mEnabled;
+    }
+
+    void setMoonEnabled(bool _enabled)
+    {
+      this->mMoonEnabled = _enabled;
+      this->mMoonManager->setEnabled(_enabled);
+    }
+
+    inline bool getMoonEnabled()
+    {
+      return this->mMoonEnabled;
+    }
+
+    void setCloudsEnabled(bool _enabled)
+    {
+      this->mCloudsEnabled = _enabled;
+      this->mVCloudsManager->getVClouds()->setEnabled(_enabled);
+    }
+
+    inline bool getCloudsEnabled()
+    {
+      return this->mCloudsEnabled;
+    }
+
 	private:
-		/// Is SkyX created?
-		bool mCreated;
+
+    /// Enable starfield?
+    bool mStarfield;
+
+    /// Lighting mode
+    LightingMode mLightingMode;
+
+    /// Scene manager
+    Ogre::SceneManager *mSceneManager;
+
+    /// Controller
+    Controller* mController;
+
+    /// Current rendering camera
+    Ogre::Camera* mCamera;
 
 		/// Mesh manager
 		MeshManager* mMeshManager;
+
 		/// Atmosphere manager
 		AtmosphereManager* mAtmosphereManager;
 		/// GPU manager
@@ -357,19 +414,12 @@
 		MoonManager* mMoonManager;
 		/// Clouds manager
 		CloudsManager* mCloudsManager;
-		/// Volumetric clouds manager
-		VCloudsManager* mVCloudsManager;
-
-		/// Controller
-		Controller* mController;
 
 		/// Render queue groups
 		RenderQueueGroups mRenderQueueGroups;
 
-		/// Scene manager
-        Ogre::SceneManager *mSceneManager;
-		/// Current rendering camera
-		Ogre::Camera* mCamera;
+    /// Is SkyX created?
+    bool mCreated;
 
 		/// Last camera position
 		Ogre::Vector3 mLastCameraPosition;
@@ -381,15 +431,22 @@
 		/// Is SkyX visible?
 		bool mVisible;
 
-		/// Lighting mode
-		LightingMode mLightingMode;
-		/// Enable starfield?
-		bool mStarfield;
-
 		/// Time multiplier
 		Ogre::Real mTimeMultiplier;
 		/// Time offset
 		Ogre::Real mTimeOffset;
+
+    /// Volumetric clouds manager
+    VCloudsManager* mVCloudsManager;
+
+    /// True if moon is enabled
+    bool mMoonEnabled;
+
+    /// True if clouds are enabled
+    bool mCloudsEnabled;
+
+    /// True if skyx is enabled
+    bool mEnabled;
 	};
 }
 
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/DataManager.h	2012-03-08 20:23:34.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/DataManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,7 @@
 #ifndef _SkyX_VClouds_DataManager_H_
 #define _SkyX_VClouds_DataManager_H_
 
+#include <vector>
 #include "Prerequisites.h"
 
 #include "VClouds/FastFakeRandom.h"
@@ -95,7 +96,8 @@
 		}
 
 		/** Set update time
-		    @param UpdateTime Time elapsed between data calculations, a little freeze could be experimented during these calculations on old CPU's
+        @param UpdateTime Time elapsed between data calculations, a little
+        freeze could be experimented during these calculations on old CPU's
 		 */
 		inline void setUpdateTime(const float& UpdateTime)
 		{
@@ -120,16 +122,24 @@
 		}
 
 		/** Set wheater parameters
-		    Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old 
+        Use this funtion to update the cloud field parameters, you'll get a
+        smart and smooth transition from your old
 			setting to your new ones.
-			@param Humidity Humidity, in other words: the percentage of clouds in [0,1] range.
-			@param AverageCloudsSize Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little)
-			       only the old biggest clouds are going to be keept and the little ones are going to be replaced
-		    @param delayedResponse false to change wheather conditions over several updates, true to change it at the moment
+        @param Humidity Humidity, in other words: the percentage of clouds
+        in [0,1] range.
+        @param AverageCloudsSize Average clouds size, for example:
+        if previous wheater clouds size parameter was very different from
+        new one(i.e: more little)
+        only the old biggest clouds are going to be keept and the little ones
+        are going to be replaced
+        @param delayedResponse false to change wheather conditions over
+        several updates, true to change it at the moment
 		 */
-		void setWheater(const float& Humidity, const float& AverageCloudsSize, const bool& delayedResponse = true);
+      void setWheater(const float& Humidity, const float& AverageCloudsSize,
+          const bool& delayedResponse = true);
 
-		/** Add ellipsoid: clouds are modelled as ellipsoids in our simulation approach, so.. different kind of clouds 
+      /** Add ellipsoid: clouds are modelled as ellipsoids in our simulation
+        approach, so.. different kind of clouds
 		    can be modelled with ellipsoids compositions.
 			@param e Ellipsoid
 			@param UpdateProbabilities Update probabilities?
@@ -156,7 +166,8 @@
 			@param init Initialize values
 			@return Cell 3d pointer
 		 */
-		Cell *** _create3DCellArray(const int& nx, const int& ny, const int& nz, const bool& init = true);
+      Cell *** _create3DCellArray(const int& nx, const int& ny, const int& nz,
+                                  const bool& init = true);
 
 		/** Delete tridimensional cell array
 			@param c Cell pointer to be deleted
@@ -172,7 +183,8 @@
 			@param ny Y size
 			@param nz Z size
 		*/
-		void _copy3DCellArraysData(Cell ***src, Cell ***dest, const int& nx, const int& ny, const int& nz);
+      void _copy3DCellArraysData(Cell ***src, Cell ***dest, const int& nx,
+                                 const int& ny, const int& nz);
 
 		/** Perform celullar automata simulation
 		    @param nx X size
@@ -182,7 +194,9 @@
 			@param xStart x start cell (included)
 			@param xEnd x end cell (not included, until xEnd-1)
 		 */
-		void _performCalculations(const int& nx, const int& ny, const int& nz, const int& step, const int& xStart, const int& xEnd);
+      void _performCalculations(const int& nx, const int& ny, const int& nz,
+                                const int& step, const int& xStart,
+                                const int& xEnd);
 
 		/** Update volumetric texture data
 		    @param c Cells data
@@ -191,7 +205,8 @@
 			@param ny Y size
 			@param nz Z size
 		 */
-		void _updateVolTextureData(Cell ***c, const VolTextureId& TexId, const int& nx, const int& ny, const int& nz);
+      void _updateVolTextureData(Cell ***c, const VolTextureId& TexId,
+          const int& nx, const int& ny, const int& nz);
 
 		/** Get continous density at a point
 		    @param c Cells data
@@ -204,7 +219,9 @@
 			@param r Radius
 			@param sgtrength Strength
 		 */	
-		const float _getDensityAt(Cell ***c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z, const int& r, const float& strength) const;
+      float _getDensityAt(Cell ***c, const int& nx, const int& ny,
+          const int& nz, const int& x, const int& y, const int& z,
+          const int& r, const float& strength) const;
 
 		/** Get discrete density at a point
 		    @param c Cells data
@@ -212,7 +229,8 @@
 			@param y y Coord
 			@param z z Coord 
 		 */	
-		const float _getDensityAt(Cell ***c, const int& x, const int& y, const int& z) const;
+      float _getDensityAt(Cell ***c, const int& x, const int& y,
+          const int& z) const;
 
 		/** Fact funtion
 		    @param c Cells data
@@ -223,7 +241,8 @@
 			@param y y Coord
 			@param z z Coord 
 		 */
-		const bool _fact(Cell ***c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z) const;
+      bool _fact(Cell ***c, const int& nx, const int& ny,
+          const int& nz, const int& x, const int& y, const int& z) const;
 
 		/** Clear probabilities
 		    @param c Cells data
@@ -232,16 +251,19 @@
 			@param nz Z size
 			@param clearData Clear data?
 		 */
-		void _clearProbabilities(Cell*** c, const int& nx, const int& ny, const int& nz, const bool& clearData);
+      void _clearProbabilities(Cell*** c, const int& nx, const int& ny,
+          const int& nz, const bool& clearData);
 
 		/** Update probabilities based from the Ellipsoid vector
 		    @param c Cells data
 			@param nx X size
 			@param ny Y size
 			@param nz Z size
-			@param delayedResponse false to change wheather conditions over several updates, true to change it at the moment
+        @param delayedResponse false to change wheather conditions over
+        several updates, true to change it at the moment
 		 */
-		void _updateProbabilities(Cell*** c, const int& nx, const int& ny, const int& nz, const bool& delayedResponse);
+      void _updateProbabilities(Cell*** c, const int& nx, const int& ny,
+          const int& nz, const bool& delayedResponse);
 
 		/** Get light absorcion factor at a point
 			@param c Cells data
@@ -254,7 +276,11 @@
 			@param d Light direction
 			@param att Attenuation factor
 		 */
-		const Ogre::Real _getLightAbsorcionAt(Cell*** c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z, const Ogre::Vector3& d, const float& att) const;
+      Ogre::Real _getLightAbsorcionAt(Cell*** c, const int& nx,
+          const int& ny, const int& nz,
+          const int& x, const int& y,
+          const int& z, const Ogre::Vector3& d,
+          const float& att) const;
 
 		/** Create volumetric texture
 			@param TexId Texture Id
@@ -262,11 +288,20 @@
 			@param ny Y size
 			@param nz Z size
 		 */
-		void _createVolTexture(const VolTextureId& TexId, const int& nx, const int& ny, const int& nz);
+      void _createVolTexture(const VolTextureId& TexId, const int& nx,
+          const int& ny, const int& nz);
+
+      /// SkyX parent pointer
+      VClouds *mVClouds;
 
 		/// Simulation data
-		Cell ***mCellsCurrent,
-			 ***mCellsTmp;
+      Cell ***mCellsCurrent, ***mCellsTmp;
+
+      /// Fast fake random
+      FastFakeRandom *mFFRandom;
+
+      /// Complexities
+      int mNx, mNy, mNz;
 
 		/// Current transition
 		float mCurrentTransition;
@@ -275,29 +310,21 @@
 		/// Current calculation state
 		int mStep, mXStart, mXEnd;
 
-		/// Complexities
-		int mNx, mNy, mNz;
+      /// Max number of clouds(Ellipsoids)
+      int mMaxNumberOfClouds;
 
 		/// Volumetric textures array
 		Ogre::TexturePtr mVolTextures[2];
+
 		/// Current texture
 		bool mVolTexToUpdate;
 
 		/// Has been create(...) already called?
 		bool mCreated;
 
-		/// Fast fake random
-		FastFakeRandom *mFFRandom;
-
-		/// Max number of clouds(Ellipsoids)
-		int mMaxNumberOfClouds;
 		/// Ellipsoids
 		std::vector<Ellipsoid*> mEllipsoids;
-
-		/// SkyX parent pointer
-		VClouds *mVClouds;
 	};
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/Ellipsoid.h	2012-03-08 20:23:34.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/Ellipsoid.h	2013-07-23 19:51:21.000000000 -0400
@@ -72,20 +72,24 @@
 			@param z z Coord 
 			@return Probabilities (Hum, Ext, Act)
 		 */
-		const Ogre::Vector3 getProbabilities(const int& x, const int& y, const int& z) const;
+    const Ogre::Vector3 getProbabilities(const int& x, const int& y,
+                                         const int& z) const;
 
 		/** Update probabilities
 			@param c Cells
 			@param nx X complexity
 			@param ny Y complexity
 			@param nz Z complexity
-			@param delayedResponse true to get a delayed response, updating only probabilities, false to also set clouds
+      @param delayedResponse true to get a delayed response,
+      updating only probabilities, false to also set clouds
 		 */
-		void updateProbabilities(DataManager::Cell ***c, const int &nx, const int &ny, const int &nz, const bool& delayedResponse = true);
+    void updateProbabilities(DataManager::Cell ***c, const int &nx,
+        const int &ny, const int &nz, const bool& delayedResponse = true);
 
-		/** Determines if the ellipsoid is out of the cells domain and needs to be removed
+    /** Determines if the ellipsoid is out of the cells domain and
+     needs to be removed
 		 */
-		const bool isOutOfCells() const;
+    bool isOutOfCells() const;
 
 		/** Get dimensions
 		    @return Ellipsoid dimensions
@@ -123,23 +127,23 @@
 		    @param x x Coord
 			@param y y Coord
 			@param z z Coord
-			@return [0,1] range where 0 is the center of the ellipsoid and 1 the superfice
+      @return [0,1] range where 0 is the center of the ellipsoid and
+      1 the superfice
 		 */
-		const float _getLength(const int& x, const int& y, const int& z) const;
+    float _getLength(const int& x, const int& y, const int& z) const;
 
 		/// Ellipsoid parameters
 		int mA, mB, mC, mA2, mB2, mC2;
 
-		/// Position
-		int mX, mY, mZ;
-
 		/// Cells size
 		int mNx, mNy, mNz;
 
+    /// Position
+    int mX, mY, mZ;
+
 		/// Cloud density
 		Ogre::Real mDensity;
 	};
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/FastFakeRandom.h	2012-03-08 20:23:34.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/FastFakeRandom.h	2013-07-23 19:51:21.000000000 -0400
@@ -36,7 +36,8 @@
 			@param min Min value
 			@param max Max value
 		 */
-		FastFakeRandom(const int& n, const Ogre::Real& min, const Ogre::Real& max);
+        FastFakeRandom(const int& n, const Ogre::Real& min,
+                       const Ogre::Real& max);
 
 		/** Destructor
 	     */
@@ -53,9 +54,7 @@
 		int mCapacity;
 		/// Index
 		int mIndex;
-
 	};
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/GeometryBlock.h	2012-12-27 00:07:14.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/GeometryBlock.h	2013-07-23 19:51:21.000000000 -0400
@@ -61,7 +61,8 @@
 			@param C C radius
 		 */
 		GeometryBlock(VClouds *vc,
-			const float& Height, const Ogre::Radian& Alpha, const Ogre::Radian& Beta, 
+          const float& Height, const Ogre::Radian& Alpha,
+          const Ogre::Radian& Beta,
 			const float& Radius, const Ogre::Radian& Phi, const int& Na, 
 			const int& Nb, const int& Nc, const int& A, 
 			const int& B, const int& C, const int& Position);
@@ -81,9 +82,8 @@
 		/** Update geometry
 		    @param c Camera
 		    @param displacement Current offset in world units per zone
-			@param distance Current camera to cloud field distance
          */
-		void updateGeometry(Ogre::Camera* c, const Ogre::Vector3& displacement, const Ogre::Vector3& distance);
+      void updateGeometry(Ogre::Camera* c, const Ogre::Vector3& displacement);
 
 		/** Has been create() already called?
 		    @return true if created() have been already called, false if not
@@ -145,11 +145,12 @@
 		    @param c Camera
 			@return true if yes, false if not
 		 */
-		const bool isInFrustum(Ogre::Camera *c) const;
+      bool isInFrustum(Ogre::Camera *c) const;
 
 	private:
 		/** Build axis aligned box
-		    @param fd Falling distance (Positive values for falling geometry, negative for reverse falling geometry)
+        @param fd Falling distance (Positive values for falling geometry,
+        negative for reverse falling geometry)
 		 */
 		const Ogre::AxisAlignedBox _buildAABox(const float& fd) const;
 
@@ -185,23 +186,21 @@
 			@param o Slice opacity
 			@param p Position
 		 */
-		void _setVertexData(const int& index, const Ogre::Vector3& p, const float& o);
+      void _setVertexData(const int& index, const Ogre::Vector3& p,
+                          const float& o);
+
+      /// VClouds pointer
+      VClouds *mVClouds;
 
 		/// Has been create() already called?
 		bool mCreated;
 
-		/// Ogre::MeshPtr
-        Ogre::MeshPtr mMesh;
         /// Ogre::Submesh pointer
         Ogre::SubMesh *mSubMesh;
+
         /// Ogre::Entity pointer
         Ogre::Entity *mEntity;
 
-        /// Vertex buffer
-        Ogre::HardwareVertexBufferSharedPtr mVertexBuffer;
-        /// Index buffer
-        Ogre::HardwareIndexBufferSharedPtr  mIndexBuffer;
-
 		/// Vertices pointer
 		VERTEX *mVertices;
 
@@ -214,42 +213,44 @@
 		float mHeight;
 		/// Angles
 		Ogre::Radian mAlpha, mBeta;
+
 		/// Radius
 		float mRadius;
+
 		/// Acimutal angle
 		Ogre::Radian mPhi;
 		/// Number of slices per geometry zone
 		int mNa, mNb, mNc;
 		/// A, B and C radius
 		float mA, mB, mC;
+
 		/// Number of block(Position)
 		int mPosition;
 
-		/// Precomputed Cos/Sin vectors
-		Ogre::Vector2 mV2Cos;
-		Ogre::Vector2 mV2Sin;
-		/// PI - Beta, PI - Alpha Sin
-		float mBetaSin;
-		float mAlphaSin;
-
 		/// Displacement
 		Ogre::Vector3 mDisplacement;
 		/// World coords offset
 		Ogre::Vector2 mWorldOffset;
 
-		/// VClouds pointer
-		VClouds *mVClouds;
 		/// Current rendering camera
 		Ogre::Camera* mCamera;
 
-		/// Current distance
-		Ogre::Vector3 mDistance;
-
 		/// Last falling distance
 		float mLastFallingDistance;
-	};
 
+      /// Ogre::MeshPtr
+      Ogre::MeshPtr mMesh;
+      /// Vertex buffer
+      Ogre::HardwareVertexBufferSharedPtr mVertexBuffer;
+      /// Index buffer
+      Ogre::HardwareIndexBufferSharedPtr  mIndexBuffer;
 
+      /// Precomputed Cos/Sin vectors
+      Ogre::Vector2 mV2Cos;
+      Ogre::Vector2 mV2Sin;
+      /// PI - Beta, PI - Alpha Sin
+      float mBetaSin;
+      float mAlphaSin;
+  };
 }}
-
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/GeometryManager.h	2012-12-27 00:41:34.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/GeometryManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,7 @@
 #ifndef _SkyX_VClouds_GeometryManager_H_
 #define _SkyX_VClouds_GeometryManager_H_
 
+#include <vector>
 #include "Prerequisites.h"
 
 #include "VClouds/GeometryBlock.h"
@@ -56,7 +57,8 @@
 		 */
 		void create(const Ogre::Vector2& Height, const float& Radius,
 		    const Ogre::Radian& Alpha, const Ogre::Radian& Beta, 
-            const int& NumberOfBlocks, const int& Na, const int& Nb, const int& Nc);
+            const int& NumberOfBlocks, const int& Na, const int& Nb,
+            const int& Nc);
 
 		/** Remove
 		 */
@@ -71,7 +73,8 @@
 		    @param c Camera
 		    @param timeSinceLastCameraFrame Time since last CAMERA frame
          */
-		void updateGeometry(Ogre::Camera* c, const Ogre::Real& timeSinceLastCameraFrame);
+    void updateGeometry(Ogre::Camera* c,
+        const Ogre::Real& timeSinceLastCameraFrame);
 
 		/** Has been create() already called?
 		    @return true if created() have been already called, false if not
@@ -89,14 +92,6 @@
 			return mSceneNode;
 		}
 
-		/** Get height (x = Altitude over the camera, y: Field height (both in world coordinates))
-		    @return Height (x = Altitude over the camera, y: Field height (both in world coordinates))
-		 */
-		inline const Ogre::Vector2 getHeight() const
-		{
-			return mHeight;
-		}
-
 		/** Set material name
 		    @param mn Material name
 		    @remarks Only for internal use
@@ -109,15 +104,6 @@
 		 */
 		void _updateRenderQueueGroup(const Ogre::uint8& rqg);
 
-		/** Get current camera to cloud field distance
-		    @return Current camera to cloud field distance
-			@remarks Only for internal use
-		 */
-		inline const Ogre::Vector3 _getCurrentDistance() const
-		{
-			return mCurrentDistance;
-		}
-
 	private:
 		/** Create geometry
 		 */
@@ -129,21 +115,31 @@
 		 */
 		void _updateGeometry(Ogre::Camera* c, const Ogre::Real& timeSinceLastFrame);
 
+    /// VClouds pointer
+    VClouds *mVClouds;
+
 		/// Has been create() already called?
 		bool mCreated;
 
-		/// Height: x = Altitude over the camera, y: Field height (both in world coordinates)
+    /// Height: x = Altitude over the camera,
+    /// y: Field height (both in world coordinates)
 		Ogre::Vector2 mHeight;
-		/// Angles
-		Ogre::Radian mAlpha, mBeta;
+
 		/// Radius
 		float mRadius;
+
+    /// Angles
+    Ogre::Radian mAlpha, mBeta;
+
 		/// Azimutal angle per block
 		Ogre::Radian mPhi;
+
 		/// Number of blocks
 		int mNumberOfBlocks;
+
 		/// Number of slices per geometry zone
 		int mNa, mNb, mNc;
+
 		/// A, B and C radius
 		float mA, mB, mC;
 
@@ -155,15 +151,7 @@
 
 		/// Scene node
 		Ogre::SceneNode *mSceneNode;
-
-		/// Current camera-clouds distance
-		Ogre::Vector3 mCurrentDistance;
-
-		/// VClouds pointer
-		VClouds *mVClouds;
 	};
-
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/Lightning.h	2012-03-13 20:29:34.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/Lightning.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,7 @@
 #ifndef _SkyX_VClouds_Lightning_H_
 #define _SkyX_VClouds_Lightning_H_
 
+#include <vector>
 #include "Prerequisites.h"
 
 namespace SkyX { namespace VClouds{
@@ -72,8 +73,12 @@
 			@param wm Width multiplier
 			@param b Bounds
 		 */
-		Lightning(Ogre::SceneManager* sm, Ogre::SceneNode* sn, const Ogre::Vector3& orig, const Ogre::Vector3& dir, const Ogre::Real& l, 
-			const Ogre::uint32& d, const Ogre::uint32& rec, const Ogre::Real& tm,  const Ogre::Real& wm, const Ogre::Vector2& b = Ogre::Vector2(0,1));
+      Lightning(Ogre::SceneManager* sm, Ogre::SceneNode* sn,
+          const Ogre::Vector3& orig, const Ogre::Vector3& dir,
+          const Ogre::Real& l,
+          const Ogre::uint32& d, const Ogre::uint32& rec,
+          const Ogre::Real& tm,  const Ogre::Real& wm,
+          const Ogre::Vector2& b = Ogre::Vector2(0, 1));
 
 		/** Destructor
 		 */
@@ -152,7 +157,8 @@
 			@param currentPos Current position
 			@param parentTime Parent time
 		 */
-		void _updateData(const Ogre::Real& alpha, const Ogre::Real& currentPos, const Ogre::Real& parentTime);
+      void _updateData(const Ogre::Real& alpha, const Ogre::Real& currentPos,
+                       const Ogre::Real& parentTime);
 
 		/// Ray origin
 		Ogre::Vector3 mOrigin;
@@ -167,23 +173,27 @@
 		Ogre::uint32 mDivisions;
 		/// Recursivity level
 		Ogre::uint32 mRecursivity;
+      /// Current elapsed time
+      Ogre::Real mTime;
+      /// Global time multiplier
+      Ogre::Real mTimeMultiplier;
+
+      /// Lightning intensity
+      Ogre::Real mIntensity;
+
 		/// Width multiplier
 		Ogre::Real mWidthMultiplier;
+
 		/// Ray bounds (for internal visual calculations)
 		Ogre::Vector2 mBounds;
-		/// Angle range (Little values -> Less derivations, bigger values -> More derivations)
+      /// Angle range (Little values -> Less derivations,
+      /// bigger values -> More derivations)
 		Ogre::Vector2 mAngleRange;
 
-		/// Current elapsed time
-		Ogre::Real mTime;
-		/// Global time multiplier
-		Ogre::Real mTimeMultiplier;
+
 		/// Per step time multipliers
 		Ogre::Vector3 mTimeMultipliers;
 
-		/// Lightning intensity
-		Ogre::Real mIntensity;
-
 		/// Segments
 		std::vector<Segment> mSegments;
 		/// Children lightnings
@@ -201,7 +211,6 @@
 		/// Has the ray finished?
 		bool mFinished;
 	};
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/LightningManager.h	2012-03-08 20:23:34.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/LightningManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,8 @@
 #ifndef _SkyX_VClouds_LightningManager_H_
 #define _SkyX_VClouds_LightningManager_H_
 
+#include <vector>
+
 #include "Prerequisites.h"
 
 #include "Lightning.h"
@@ -42,18 +44,21 @@
 		public:
 			/** Lightning added
 			    @param l Lightning that has been added
-				@remarks Useful when, for example, the app needs to known when a Lightning has been created (by manually
-						 invoking LightningManager::addLightning(...) or automatically based on the lightning creation
-						 probabilities) in order to play a sound, etc.
-						 The lightning position is accessible through Lightning::getSceneNode()->getPosition().
+        @remarks Useful when, for example, the app needs to known when a
+        Lightning has been created (by manually invoking
+        LightningManager::addLightning(...) or automatically based on the
+        lightning creation probabilities) in order to play a sound, etc.
+        The lightning position is accessible through
+        Lightning::getSceneNode()->getPosition().
 			 */
 			inline virtual void lightningAdded(Lightning* l){}
+      virtual ~Listener() {}
 		};
 
 		/** Constructor
 			@param vc VClouds pointer
 		 */
-		LightningManager(VClouds* vc);
+    explicit LightningManager(VClouds* vc);
 
 		/** Destructor
 		 */
@@ -76,11 +81,16 @@
 		    @param p Lightning position
 			@param d Lightning direction
 			@param l Lightning length
-			@return The lightning or null in error case (the max number of simultaneous lightnings is 3)
-			@remarks The lightning will be automatically destroyed one time it'll be finished, so the returned ptr will not
+      @return The lightning or null in error case (the max number of
+      simultaneous lightnings is 3)
+      @remarks The lightning will be automatically destroyed one time
+      it'll be finished, so the returned ptr will not
 					 be available one time the lightning will have disappeared
 		 */
-		Lightning* addLightning(const Ogre::Vector3& p, const Ogre::Vector3& d, const Ogre::Real l, const Ogre::uint32& div = static_cast<Ogre::uint32>(Ogre::Math::RangeRandom(12, 30)));
+    Lightning* addLightning(const Ogre::Vector3& p, const Ogre::Vector3& d,
+        const Ogre::Real l,
+        const Ogre::uint32& div = static_cast<Ogre::uint32>(
+          Ogre::Math::RangeRandom(12, 30)));
 
 		/** Update material
 		    @remarks To be invoked before each camera rendering process
@@ -186,7 +196,8 @@
 
 		/** Update render queue group
 		    @param rqg Render queue group
-		    @remarks Only for internal use. Use VClouds::setRenderQueueGroups(...) instead.
+        @remarks Only for internal use.
+        Use VClouds::setRenderQueueGroups(...) instead.
 		 */
 		void _updateRenderQueueGroup(const Ogre::uint8& rqg);
 
@@ -197,6 +208,9 @@
 		void _setVisible(const bool& v);
 
 	private:
+    /// VClouds pointer
+    VClouds *mVClouds;
+
 		/// Lightnings
 		std::vector<Lightning*> mLightnings;
 		/// Scene nodes
@@ -225,11 +239,6 @@
 
 		/// Has been create() already called?
 		bool mCreated;
-
-		/// VClouds pointer
-		VClouds *mVClouds;
 	};
-
 }}
-
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VClouds/VClouds.h	2012-12-27 00:33:28.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VClouds/VClouds.h	2013-07-23 19:51:21.000000000 -0400
@@ -24,6 +24,8 @@
 #ifndef _SkyX_VClouds_VClouds_H_
 #define _SkyX_VClouds_VClouds_H_
 
+#include <vector>
+
 #include "Prerequisites.h"
 
 #include "VClouds/DataManager.h"
@@ -41,27 +43,25 @@
 		{
 			/** Constructor
 				@param vc VClouds render queue group
-				@param vclu VClouds lightnings render queue group (when the camera is under the cloud field)
-				@param vclo VClouds lightnings render queue group (when the camera is over the cloud field)
+        @param vcl VClouds lightnings render queue group
 			 */
-			inline RenderQueueGroups(const Ogre::uint8& vc, const Ogre::uint8& vclu, const Ogre::uint8& vclo)
-				: vclouds(vc), vcloudsLightningsUnder(vclu), vcloudsLightningsOver(vclo)
+      inline RenderQueueGroups(const Ogre::uint8& vc, const Ogre::uint8& vcl)
+        : vclouds(vc), vcloudsLightnings(vcl)
 			{
 			}
 
 			/// VClouds render queue group
 			Ogre::uint8 vclouds;
-			/// VClouds lightnings render queue group (when the camera is under the cloud field)
-			Ogre::uint8 vcloudsLightningsUnder;
-			/// VClouds lightnings render queue group (when the camera is over the cloud field)
-			Ogre::uint8 vcloudsLightningsOver;
+      /// VClouds lightnings render queue group
+      Ogre::uint8 vcloudsLightnings;
 		};
 
 		/** Geometry settings
 		 */
 		struct GeometrySettings 
 		{
-			/// Height: x = Altitude over the camera, y: Field height (both in world coordinates)
+      /// Height: x = Altitude over the camera,
+      /// y: Field height (both in world coordinates)
 			Ogre::Vector2 Height;
 			/// Angles
 			Ogre::Radian Alpha, Beta;
@@ -84,7 +84,8 @@
 			}
 
 			/** Constructor
-			    @param _Height x = Cloud field y-coord start, y: Field height (both in world coordinates)
+          @param _Height x = Cloud field y-coord start,
+                         y: Field height (both in world coordinates)
 				@param _Radius Radius
 				@param _Alpha Alpha angle
 				@param _Beta Beta angle
@@ -94,10 +95,12 @@
 				@param _Nc Number of slices in C zone
 			 */
 			GeometrySettings(const Ogre::Vector2& _Height, const float& _Radius,
-					const Ogre::Radian& _Alpha = Ogre::Degree(12), const Ogre::Radian& _Beta = Ogre::Degree(40), 
-					const int& _NumberOfBlocks = 12, const int& _Na = 10, const int& _Nb = 8, const int& _Nc = 6)
+          const Ogre::Radian& _Alpha = Ogre::Degree(12),
+          const Ogre::Radian& _Beta = Ogre::Degree(40),
+          const int& _NumberOfBlocks = 12, const int& _Na = 10,
+          const int& _Nb = 8, const int& _Nc = 6)
 				: Height(_Height)
-				, Alpha(_Radius), Beta(_Beta)
+        , Alpha(_Alpha), Beta(_Beta)
 				, Radius(_Radius)
 				, NumberOfBlocks(_NumberOfBlocks)
 				, Na(_Na), Nb(_Nb), Nc(_Nc)
@@ -123,7 +126,7 @@
 			/** Constructor
 			    @param c Camera
 			 */
-			inline CameraData(Ogre::Camera* c)
+      explicit inline CameraData(Ogre::Camera* c)
 				: camera(c)
 				, lastPosition(c->getDerivedPosition())
 				, cameraOffset(Ogre::Vector2(0,0))
@@ -160,7 +163,8 @@
 		void create(const GeometrySettings& gs);
 
 		/** Create
-			@param Height x = Cloud field y-coord start, y: Field height (both in world coordinates)
+      @param Height x = Cloud field y-coord start,
+       y: Field height (both in world coordinates)
 			@param Radius Radius
 		 */
 		void create(const Ogre::Vector2& Height, const float& Radius);
@@ -178,19 +182,22 @@
 			@param c Rendering camera
 		    @param timeSinceLastCameraFrame Time since last CAMERA frame
          */
-        void notifyCameraRender(Ogre::Camera* c, const Ogre::Real& timeSinceLastCameraFrame);
+        void notifyCameraRender(Ogre::Camera* c,
+                                const Ogre::Real& timeSinceLastCameraFrame);
 
 		/** Register camera
 		    @param c Camera
-			@remarks If a rendering camera is used(in notifyCameraRender(...)) without having registered it before,
-			         all will work as expected but a warning will be logged since the user should manually unregister 
-					 the camera one time it'll be remove
+      @remarks If a rendering camera is used(in notifyCameraRender(...))
+      without having registered it before,
+      all will work as expected but a warning will be logged since the
+      user should manually unregister the camera one time it'll be remove
 		 */
 		void registerCamera(Ogre::Camera* c);
 
 		/** Unregister camera
 		    @param c Camera
-			@remarks After having used a camera (i.e. before removing the camera), the user should manually unregister it
+      @remarks After having used a camera (i.e. before removing the camera),
+      the user should manually unregister it
 		 */
 		void unregisterCamera(Ogre::Camera* c);
 
@@ -229,18 +236,23 @@
 											 -1 means not max falling. (default)
 			@remarks See GoemetryBlock::_setVertexData(...) for more info
 		*/
-		inline void setDistanceFallingParams(const Ogre::Vector2& DistanceFallingParams)
+    inline void setDistanceFallingParams(
+        const Ogre::Vector2& DistanceFallingParams)
 		{
 			mDistanceFallingParams = DistanceFallingParams;
 		}
 
 		/** Get distance falling params
-		    @return DistanceFallingParams.x = Distance falling factor (How much the cloud field geometry falls with the distance)
-									          Remember that the geometry falling is relative to the distance(height) between the camera
+      @return DistanceFallingParams.x = Distance falling factor
+      (How much the cloud field geometry falls with the distance)
+      Remember that the geometry falling is relative to the distance(height)
+      between the camera
 											  and the cloud field.
 											  Typical range is [0, ~2] 0 = no falling
-				    DistanceFallingParams.y = Max falling (in world coords), useful when , i.e., you've water and you want to go in. 
-									  	      That param will allow you to avoid the cloud field geometry falls into the ocean. 
+      DistanceFallingParams.y = Max falling (in world coords),
+      useful when , i.e., you've water and you want to go in.
+      That param will allow you to avoid the cloud field geometry falls
+      into the ocean.
 											  -1 means not max falling. (default)
 			@remarks See GoemetryBlock::_setVertexData(...) for more info
 		 */
@@ -283,7 +295,8 @@
 		 */
 		inline const Ogre::Vector2 getWindDirectionV2() const
 		{
-			return Ogre::Vector2(Ogre::Math::Cos(mWindDirection), Ogre::Math::Sin(mWindDirection));
+      return Ogre::Vector2(Ogre::Math::Cos(mWindDirection),
+                           Ogre::Math::Sin(mWindDirection));
 		}
 
 		/** Set wind speed
@@ -423,17 +436,24 @@
 		}
 
 		/** Set wheater parameters
-		    Use this funtion to update the cloud field parameters, you'll get a smart and smooth transition from your old 
-			setting to your new ones.
-			@param Humidity Humidity, in other words: the percentage of clouds in [0,1] range.
-			@param AverageCloudsSize Average clouds size, for example: if previous wheater clouds size parameter was very different from new one(i.e: more little)
-			       only the old biggest clouds are going to be keept and the little ones are going to be replaced
-		    @param DelayedResponse false to change wheather conditions over several updates, true to change it at the moment
+        Use this funtion to update the cloud field parameters, you'll get a
+        smart and smooth transition from your old setting to your new ones.
+        @param Humidity Humidity, in other words: the percentage of clouds
+        in [0,1] range.
+      @param AverageCloudsSize Average clouds size, for example: if
+      previous wheater clouds size parameter was very different from
+      new one(i.e: more little)
+      only the old biggest clouds are going to be keept and the little
+      ones are going to be replaced
+      @param DelayedResponse false to change wheather conditions over
+      several updates, true to change it at the moment
 		 */
-		void setWheater(const float& Humidity, const float& AverageCloudsSize, const bool& DelayedResponse);
+    void setWheater(const float& Humidity, const float& AverageCloudsSize,
+        const bool& DelayedResponse);
 
 		/** Get wheater
-		    @return Wheater parameters: x = Humidity, y = Average clouds size, both un [0,1] range
+        @return Wheater parameters: x = Humidity,
+        y = Average clouds size, both un [0,1] range
 		 */
 		inline const Ogre::Vector2& getWheater() const
 		{
@@ -445,6 +465,11 @@
 		 */
 		void setVisible(const bool& visible);
 
+    /** Set enable
+        @param _enabled true to set VClouds to be enabled, false to hide it
+     */
+    void setEnabled(bool _enabled);
+
 		/** Is VClouds visible?
 		    @return true if VClouds is visible, false otherwise
 		 */
@@ -503,6 +528,12 @@
 		}
 
 	private:
+    /// Ogre::SceneManager pointer
+    Ogre::SceneManager *mSceneManager;
+
+    /// Current rendering camera
+    Ogre::Camera* mCamera;
+
 		/// Has been create(...) already called?
 		bool mCreated;
 
@@ -520,9 +551,11 @@
 		/// Wind speed
 		float mWindSpeed;
 
-		/// Wheater parameters: x = Humidity, y = Average clouds size, both un [0,1] range
+    /// Wheater parameters: x = Humidity, y = Average clouds size,
+    /// both un [0,1] range
 		Ogre::Vector2 mWheater;
-		/// Delayed response (This param is stored to allow the user call setWheater(...) before create() )
+    /// Delayed response (This param is stored to allow the user call
+    /// setWheater(...) before create() )
 		bool mDelayedResponse;
 
 		/// Sun direction
@@ -563,20 +596,15 @@
 		/// Lightning manager
 		LightningManager *mLightningManager;
 
-		/// Ogre::SceneManager pointer
-        Ogre::SceneManager *mSceneManager;
-		/// Current rendering camera
-		Ogre::Camera* mCamera;
+    /// Cameras data
+    std::vector<CameraData> mCamerasData;
 
 		/// Vol. clouds material
 		Ogre::MaterialPtr mVolCloudsMaterial;
+
 		/// Vol. clouds + lightning material
 		Ogre::MaterialPtr mVolCloudsLightningMaterial;
-
-		/// Cameras data
-		std::vector<CameraData> mCamerasData;
 	};
-
 }}
 
 #endif
\ No newline at end of file
unchanged:
--- SkyX-0.4/SkyX/Include/VCloudsManager.h	2012-03-08 20:29:48.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/include/VCloudsManager.h	2013-07-23 19:51:21.000000000 -0400
@@ -176,29 +176,31 @@
 		 */
 		void _setLightParameters();
 
-		/// Ambient and Sun color gradients
-		ColorGradient mAmbientGradient;
-		ColorGradient mSunGradient;
+    /// SkyX parent pointer
+    SkyX *mSkyX;
 
 		/// VClouds pointer
 		VClouds::VClouds* mVClouds;
 
-		/// Height parameters, x = Cloud field y-coord start, y: Field height (both in world coordinates)
+    /// Height parameters, x = Cloud field y-coord start,
+    /// y: Field height (both in world coordinates)
 		Ogre::Vector2 mHeight;
 
-		/// Autoupdate wind speed depending of skyx time multiplier?
-		bool mAutoupdate;
 		/// Wind speed
 		Ogre::Real mWindSpeed;
 
+    /// Autoupdate wind speed depending of skyx time multiplier?
+    bool mAutoupdate;
+
 		/// Is vclouds manager created?
 		bool mCreated;
 
 		/// Current time since last frame
 		Ogre::Real mCurrentTimeSinceLastFrame;
 
-		/// SkyX parent pointer
-		SkyX *mSkyX;
+    /// Ambient and Sun color gradients
+    ColorGradient mAmbientGradient;
+    ColorGradient mSunGradient;
 	};
 }
 
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/AtmosphereManager.cpp	2012-12-28 23:39:40.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/AtmosphereManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <algorithm>
 #include "AtmosphereManager.h"
 
 #include "SkyX.h"
@@ -39,12 +40,13 @@
 	{
 	}
 
-	void AtmosphereManager::_update(const Options& NewOptions, const bool& ForceToUpdateAll)
+  void AtmosphereManager::_update(const Options& NewOptions,
+                                  const bool& ForceToUpdateAll)
 	{
 		GPUManager *mGPUManager = mSkyX->getGPUManager();
 
-		if (NewOptions.InnerRadius != mOptions.InnerRadius || 
-			NewOptions.OuterRadius != mOptions.OuterRadius ||
+    if (!equal(NewOptions.InnerRadius, mOptions.InnerRadius) ||
+        !equal(NewOptions.OuterRadius, mOptions.OuterRadius) ||
 			ForceToUpdateAll)
 		{
 			mOptions.InnerRadius = NewOptions.InnerRadius;
@@ -54,24 +56,34 @@
 				  ScaleDepth = (mOptions.OuterRadius - mOptions.InnerRadius) / 2.0f,
 				  ScaleOverScaleDepth = Scale / ScaleDepth;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uInnerRadius", mOptions.InnerRadius);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uCameraPos", Ogre::Vector3(0, mOptions.InnerRadius + (mOptions.OuterRadius-mOptions.InnerRadius)*mOptions.HeightPosition, 0));
-
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uScale", Scale);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uScaleDepth", ScaleDepth);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uScaleOverScaleDepth", ScaleOverScaleDepth);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uInnerRadius", mOptions.InnerRadius);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uCameraPos", Ogre::Vector3(0, mOptions.InnerRadius +
+            (mOptions.OuterRadius-mOptions.InnerRadius)*
+            mOptions.HeightPosition, 0));
+
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uScale",
+          Scale);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uScaleDepth", ScaleDepth);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uScaleOverScaleDepth", ScaleOverScaleDepth);
 		}
 
-		if (NewOptions.HeightPosition != mOptions.HeightPosition ||
+    if (!equal(NewOptions.HeightPosition, mOptions.HeightPosition) ||
 			ForceToUpdateAll)
 		{
 			mOptions.HeightPosition = NewOptions.HeightPosition;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uCameraPos", Ogre::Vector3(0, mOptions.InnerRadius + (mOptions.OuterRadius-mOptions.InnerRadius)*mOptions.HeightPosition, 0));
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uCameraPos", Ogre::Vector3(0, mOptions.InnerRadius +
+            (mOptions.OuterRadius-mOptions.InnerRadius)*
+            mOptions.HeightPosition, 0));
 		}
 
-		if (NewOptions.RayleighMultiplier != mOptions.RayleighMultiplier ||
-			NewOptions.SunIntensity       != mOptions.SunIntensity       ||
+    if (!equal(NewOptions.RayleighMultiplier, mOptions.RayleighMultiplier) ||
+        !equal(NewOptions.SunIntensity, mOptions.SunIntensity) ||
 			ForceToUpdateAll)
 		{
 			mOptions.RayleighMultiplier = NewOptions.RayleighMultiplier;
@@ -79,12 +91,14 @@
 			float Kr4PI  = mOptions.RayleighMultiplier * 4.0f * Ogre::Math::PI,
 				  KrESun = mOptions.RayleighMultiplier * mOptions.SunIntensity;
 
-            mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uKr4PI", Kr4PI);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uKrESun", KrESun);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uKr4PI", Kr4PI);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uKrESun", KrESun);
 		}
 
-		if (NewOptions.MieMultiplier != mOptions.MieMultiplier ||
-			NewOptions.SunIntensity  != mOptions.SunIntensity  ||
+    if (!equal(NewOptions.MieMultiplier, mOptions.MieMultiplier) ||
+        !equal(NewOptions.SunIntensity, mOptions.SunIntensity)  ||
 			ForceToUpdateAll)
 		{
 			mOptions.MieMultiplier = NewOptions.MieMultiplier;
@@ -92,8 +106,10 @@
 			float Km4PI  = mOptions.MieMultiplier * 4.0f * Ogre::Math::PI,
 				  KmESun = mOptions.MieMultiplier * mOptions.SunIntensity;
 
-            mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uKm4PI", Km4PI);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uKmESun", KmESun, false);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uKm4PI", Km4PI);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uKmESun", KmESun, false);
 		}
 
 		if (NewOptions.NumberOfSamples != mOptions.NumberOfSamples ||
@@ -101,8 +117,10 @@
 		{
 			mOptions.NumberOfSamples = NewOptions.NumberOfSamples;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uNumberOfSamples", mOptions.NumberOfSamples);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uSamples", static_cast<Ogre::Real>(mOptions.NumberOfSamples));
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uNumberOfSamples", mOptions.NumberOfSamples);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uSamples", static_cast<Ogre::Real>(mOptions.NumberOfSamples));
 		}
 
 		if (NewOptions.WaveLength != mOptions.WaveLength ||
@@ -110,44 +128,49 @@
 		{
 			mOptions.WaveLength = NewOptions.WaveLength;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uInvWaveLength", 
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+          "uInvWaveLength",
 				Ogre::Vector3(1.0f / Ogre::Math::Pow(mOptions.WaveLength.x, 4.0f),
 				              1.0f / Ogre::Math::Pow(mOptions.WaveLength.y, 4.0f),
 				              1.0f / Ogre::Math::Pow(mOptions.WaveLength.z, 4.0f)));
 		}
 
-		if (NewOptions.G != mOptions.G ||
-			ForceToUpdateAll)
+    if (!equal(NewOptions.G, mOptions.G) || ForceToUpdateAll)
 		{
 			mOptions.G = NewOptions.G;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uG", mOptions.G, false);
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uG2", mOptions.G*mOptions.G, false);
+      mGPUManager->setGpuProgramParameter(
+          GPUManager::GPUP_FRAGMENT, "uG", mOptions.G, false);
+      mGPUManager->setGpuProgramParameter(
+          GPUManager::GPUP_FRAGMENT, "uG2", mOptions.G*mOptions.G, false);
 		}
 
-		if (NewOptions.Exposure != mOptions.Exposure ||
-			ForceToUpdateAll)
+    if (!equal(NewOptions.Exposure, mOptions.Exposure) || ForceToUpdateAll)
 		{
 			mOptions.Exposure = NewOptions.Exposure;
 
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uExposure", mOptions.Exposure);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT,
+          "uExposure", mOptions.Exposure);
 		}
 
 		mSkyX->getCloudsManager()->update();
 	}
 
-	const float AtmosphereManager::_scale(const float& cos, const float& uScaleDepth) const
+  float AtmosphereManager::_scale(const float& cos,
+      const float& uScaleDepth) const
 	{
 		float x = 1 - cos;
-		return uScaleDepth * Ogre::Math::Exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
+    return uScaleDepth * Ogre::Math::Exp(-0.00287 +
+        x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
 	}
 
-	const Ogre::Vector3 AtmosphereManager::getColorAt(const Ogre::Vector3& Direction) const
+  const Ogre::Vector3 AtmosphereManager::getColorAt(
+      const Ogre::Vector3& Direction) const
 	{
-		/*if (Direction.y < 0)
+    if (Direction.y < 0)
 		{
 			return Ogre::Vector3(0,0,0);
-		}*/
+    }
 		
 		// Parameters
 		double Scale = 1.0f / (mOptions.OuterRadius - mOptions.InnerRadius),
@@ -161,8 +184,10 @@
 		// --- Start vertex program simulation ---
 		Ogre::Vector3
 			uLightDir = mSkyX->getController()->getSunDirection(),
-			v3Pos = Direction.normalisedCopy(),
-			uCameraPos = Ogre::Vector3(0, mOptions.InnerRadius + (mOptions.OuterRadius-mOptions.InnerRadius)*mOptions.HeightPosition, 0),
+                v3Pos = Direction,
+                uCameraPos = Ogre::Vector3(0, mOptions.InnerRadius +
+                    (mOptions.OuterRadius-mOptions.InnerRadius)*
+                    mOptions.HeightPosition, 0),
 			uInvWaveLength = Ogre::Vector3(
 			                    1.0f / Ogre::Math::Pow(mOptions.WaveLength.x, 4.0f),
 			                    1.0f / Ogre::Math::Pow(mOptions.WaveLength.y, 4.0f),
@@ -174,31 +199,35 @@
 		double fFar = v3Ray.length();
 		v3Ray /= fFar;
 
-		// Calculate the ray's starting position, then calculate its scattering offset
+    // Calculate the ray's starting position, then calculate
+    // its scattering offset
 		Ogre::Vector3 v3Start = uCameraPos;
 		double fHeight = uCameraPos.y,
 		       fStartAngle = v3Ray.dotProduct(v3Start) / fHeight,
-		       fDepth = Ogre::Math::Exp(ScaleOverScaleDepth * (mOptions.InnerRadius - uCameraPos.y)),
+           fDepth = Ogre::Math::Exp(ScaleOverScaleDepth *
+               (mOptions.InnerRadius - uCameraPos.y)),
 		       fStartOffset = fDepth * _scale(fStartAngle, ScaleDepth);
 
 		// Init loop variables
-		double fSampleLength = fFar /(double)mOptions.NumberOfSamples,
+    double fSampleLength = fFar /static_cast<double>(mOptions.NumberOfSamples),
 		       fScaledLength = fSampleLength * Scale,
 			   fHeight_, fDepth_, fLightAngle, fCameraAngle, fScatter;
 		Ogre::Vector3 v3SampleRay = v3Ray * fSampleLength,
 		              v3SamplePoint = v3Start + v3SampleRay * 0.5f,
-					  color = Ogre::Vector3(0,0,0), v3Attenuate;
+      color, v3Attenuate;
 
         // Loop the ray
 		for (int i = 0; i < mOptions.NumberOfSamples; i++)
 		{
 			fHeight_ = v3SamplePoint.length();
-			fDepth_ = Ogre::Math::Exp(ScaleOverScaleDepth * (mOptions.InnerRadius-fHeight_));
+      fDepth_ = Ogre::Math::Exp(ScaleOverScaleDepth *
+          (mOptions.InnerRadius-fHeight_));
 
 			fLightAngle = uLightDir.dotProduct(v3SamplePoint) / fHeight_;
 			fCameraAngle = v3Ray.dotProduct(v3SamplePoint) / fHeight_;
 
-			fScatter = (fStartOffset + fDepth*(_scale(fLightAngle, ScaleDepth) - _scale(fCameraAngle, ScaleDepth)));
+      fScatter = (fStartOffset + fDepth*(_scale(fLightAngle, ScaleDepth) -
+            _scale(fCameraAngle, ScaleDepth)));
 
 			v3Attenuate = Ogre::Vector3(
 				Ogre::Math::Exp(-fScatter * (uInvWaveLength.x * Kr4PI + Km4PI)),
@@ -226,36 +255,32 @@
 		       rayleighPhase = 0.75 * (1.0 + 0.5*cos2),
 			   g2 = mOptions.G*mOptions.G,
 		       miePhase = 1.5f * ((1.0f - g2) / (2.0f + g2)) * 
-			            (1.0f + cos2) / Ogre::Math::Pow(1.0f + g2 - 2.0f * mOptions.G * cos, 1.5f);
+             (1.0f + cos2) /
+             Ogre::Math::Pow(1.0f + g2 - 2.0f * mOptions.G * cos, 1.5f);
 
 		Ogre::Vector3 oColor;
 
 		if (mSkyX->getLightingMode() == SkyX::LM_LDR)
 		{
 			oColor = Ogre::Vector3(
-				1 - Ogre::Math::Exp(-mOptions.Exposure * (rayleighPhase * oRayleighColor.x + miePhase * oMieColor.x)),
-				1 - Ogre::Math::Exp(-mOptions.Exposure * (rayleighPhase * oRayleighColor.y + miePhase * oMieColor.y)),
-				1 - Ogre::Math::Exp(-mOptions.Exposure * (rayleighPhase * oRayleighColor.z + miePhase * oMieColor.z)));
-		
-			// For night rendering
-			oColor += Ogre::Math::Clamp<Ogre::Real>(((1 - std::max(oColor.x, std::max(oColor.y, oColor.z))*10)), 0, 1) 
-				* (Ogre::Vector3(0.05, 0.05, 0.1)
-				* (2-0.75f*Ogre::Math::Clamp<Ogre::Real>(-uLightDir.y, 0, 1)) * Ogre::Math::Pow(1-Direction.y, 3));
+          1 - Ogre::Math::Exp(-mOptions.Exposure *
+            (rayleighPhase * oRayleighColor.x + miePhase * oMieColor.x)),
+          1 - Ogre::Math::Exp(-mOptions.Exposure *
+            (rayleighPhase * oRayleighColor.y + miePhase * oMieColor.y)),
+          1 - Ogre::Math::Exp(-mOptions.Exposure *
+            (rayleighPhase * oRayleighColor.z + miePhase * oMieColor.z)));
 		}
 		else
 		{
-			oColor = mOptions.Exposure * (rayleighPhase * oRayleighColor + miePhase * oMieColor);
-		
-			Ogre::Real nightmult = Ogre::Math::Clamp<Ogre::Real>(((1 - std::max(oColor.x, std::max(oColor.y, oColor.z))*10)), 0, 1);
+      oColor = rayleighPhase * oRayleighColor + miePhase * oMieColor;
+    }
 
 			// For night rendering
-			Ogre::Vector3 nightCol =  Ogre::Vector3(0.05, 0.05, 0.1) * (2-0.75f*Ogre::Math::Clamp<Ogre::Real>(-uLightDir.y, 0, 1)) * Ogre::Math::Pow(1-Direction.y, 3);
-			nightCol.x = Ogre::Math::Pow(nightCol.x, 2.2);
-			nightCol.y = Ogre::Math::Pow(nightCol.y, 2.2);
-			nightCol.z = Ogre::Math::Pow(nightCol.z, 2.2);
-
-			oColor += nightmult*nightCol;
-		}
+    oColor += Ogre::Math::Clamp<Ogre::Real>(((1 -
+            std::max(oColor.x, std::max(oColor.y, oColor.z))*10)), 0, 1)
+      * (Ogre::Vector3(0.05, 0.05, 0.1)
+          * (2-0.75f*Ogre::Math::Clamp<Ogre::Real>(-uLightDir.y, 0, 1)) *
+          Ogre::Math::Pow(1-Direction.y, 3));
 
 		// --- End fragment program simulation ---
 
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/BasicController.cpp	2012-09-25 21:18:18.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/BasicController.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -125,7 +125,7 @@
 		      sn = Ogre::Math::Sin(ydeg),
 		      cs = Ogre::Math::Cos(ydeg);
 
-		mSunDirection = Ogre::Vector3(East.x*cs, sn, East.y*cs);
+    mSunDirection = Ogre::Vector3(East.x*cs, East.y*cs, sn);
 		mMoonDirection = -mSunDirection;
 	}
 }
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/CloudsManager.cpp	2012-08-29 11:50:18.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/CloudsManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -29,53 +29,83 @@
 {
 	/// -------------- CloudLayer -----------------
 	CloudLayer::CloudLayer(SkyX *s)
-		: mSkyX(s)
-		, mOptions(Options())
-		, mCloudLayerPass(0)
+    : mSkyX(s),
+    mOptions(Options()),
+    mCloudLayerPass(0)
 	{
 		mAmbientGradient = ColorGradient();
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.95f, 1.0f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.7,0.7,0.65), 0.625f)); 
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.55,0.4), 0.5625f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.45,0.3)*0.4, 0.5f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.25,0.25)*0.1, 0.45f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.3)*0.1, 0.35f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.5)*0.15, 0));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.95f, 1.0f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.7, 0.7, 0.65), 0.625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.55, 0.4), 0.5625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.45, 0.3)*0.4, 0.5f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.25, 0.25)*0.1, 0.45f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.3)*0.1, 0.35f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.5)*0.15, 0));
 
 		mSunGradient = ColorGradient();
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.95f, 1.0f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.8, 0.75f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.8,0.75,0.55)*1.3, 0.5625f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.75, 0.5f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.35, 0.4725f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.5,0.5)*0.15, 0.45f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.25)*0.5, 0.3f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.5,0.5)*0.35, 0.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.95f, 1.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.8, 0.75f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.8, 0.75, 0.55)*1.3, 0.5625f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.75, 0.5f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.35, 0.4725f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.5, 0.5)*0.15, 0.45f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.25)*0.5, 0.3f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.5, 0.5)*0.35, 0.0f));
 	}
 
 	CloudLayer::CloudLayer(SkyX *s, const Options& o)
-		: mSkyX(s)
-		, mOptions(o)
-		, mCloudLayerPass(0)
+    : mSkyX(s),
+    mOptions(o),
+    mCloudLayerPass(0)
 	{
 		mAmbientGradient = ColorGradient();
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.95f, 1.0f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.7,0.7,0.65), 0.625f)); 
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.55,0.4), 0.5625f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.45,0.3)*0.4, 0.5f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.25,0.25)*0.1, 0.45f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.3)*0.1, 0.35f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.5)*0.15, 0));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.95f, 1.0f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.7, 0.7, 0.65), 0.625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.55, 0.4), 0.5625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.45, 0.3)*0.4, 0.5f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.25, 0.25)*0.1, 0.45f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.3)*0.1, 0.35f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.5)*0.15, 0));
 
 		mSunGradient = ColorGradient();
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.95f, 1.0f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.8, 0.75f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.8,0.75,0.55)*1.3, 0.5625f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.75, 0.5f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.35, 0.4725f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.5,0.5)*0.15, 0.45f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.25)*0.5, 0.3f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.5,0.5,0.5)*0.35, 0.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.95f, 1.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.8, 0.75f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.8, 0.75, 0.55)*1.3, 0.5625f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.75, 0.5f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.35, 0.4725f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.5, 0.5)*0.15, 0.45f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.25)*0.5, 0.3f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.5, 0.5, 0.5)*0.35, 0.0f));
 	}
 
 	CloudLayer::~CloudLayer()
@@ -103,9 +133,15 @@
 		}
 
 		// TODO
-		CloudLayerPass->createTextureUnitState("Clouds.png")->setTextureAddressingMode(Ogre::TextureUnitState::TAM_WRAP);
-		CloudLayerPass->createTextureUnitState("CloudsNormal.png")->setTextureAddressingMode(Ogre::TextureUnitState::TAM_WRAP);
-		CloudLayerPass->createTextureUnitState("CloudsTile.png")->setTextureAddressingMode(Ogre::TextureUnitState::TAM_WRAP);
+    CloudLayerPass->createTextureUnitState(
+        "Clouds.png")->setTextureAddressingMode(
+          Ogre::TextureUnitState::TAM_WRAP);
+    CloudLayerPass->createTextureUnitState(
+        "CloudsNormal.png")->setTextureAddressingMode(
+          Ogre::TextureUnitState::TAM_WRAP);
+    CloudLayerPass->createTextureUnitState(
+        "CloudsTile.png")->setTextureAddressingMode(
+          Ogre::TextureUnitState::TAM_WRAP);
 
 		mCloudLayerPass = CloudLayerPass;
 
@@ -134,7 +170,8 @@
 		mCloudLayerPass->getFragmentProgramParameters()
 			->setNamedConstant("uHeight", mOptions.Height);
 
-		float WindDirection_[2] = {mOptions.WindDirection.x, mOptions.WindDirection.y};
+    float WindDirection_[2] = {mOptions.WindDirection.x,
+      mOptions.WindDirection.y};
 
 		mCloudLayerPass->getFragmentProgramParameters()
 			->setNamedConstant("uWindDirection", WindDirection_, 1, 2);
@@ -142,7 +179,8 @@
 		mCloudLayerPass->getFragmentProgramParameters()
 			->setNamedConstant("uCloudLayerHeightVolume", mOptions.HeightVolume);
 		mCloudLayerPass->getFragmentProgramParameters()
-			->setNamedConstant("uCloudLayerVolumetricDisplacement", mOptions.VolumetricDisplacement);
+      ->setNamedConstant("uCloudLayerVolumetricDisplacement",
+          mOptions.VolumetricDisplacement);
 		mCloudLayerPass->getFragmentProgramParameters()
 			->setNamedConstant("uDetailAttenuation", mOptions.DetailAttenuation);
 		mCloudLayerPass->getFragmentProgramParameters()
@@ -157,12 +195,16 @@
 		}
 
 		mCloudLayerPass->getFragmentProgramParameters()
-			->setNamedConstant("uExposure", mSkyX->getAtmosphereManager()->getOptions().Exposure);
+      ->setNamedConstant("uExposure",
+          mSkyX->getAtmosphereManager()->getOptions().Exposure);
 		mCloudLayerPass->getFragmentProgramParameters()
-			->setNamedConstant("uTime", mSkyX->_getTimeOffset()*mOptions.TimeMultiplier);
+      ->setNamedConstant("uTime", mSkyX->_getTimeOffset()*
+          mOptions.TimeMultiplier);
 		/*
 		mCloudLayerPass->getFragmentProgramParameters()
-			->setNamedConstant("uSunPosition", -mSkyX->getAtmosphereManager()->getSunDirection()*mSkyX->getMeshManager()->getSkydomeRadius());
+       ->setNamedConstant("uSunPosition",
+       -mSkyX->getAtmosphereManager()->getSunDirection()*
+       mSkyX->getMeshManager()->getSkydomeRadius());
 		
 		Ogre::Vector3 AmbientColor = Ogre::Vector3::ZERO;
 
@@ -170,9 +212,12 @@
 		Ogre::Real Ang = 0;
 		for (int k = 0; k < 3; k++)
 		{
-			Ogre::Vector2 Coords = Ogre::Vector2(Ogre::Math::Cos(Ang), Ogre::Math::Sin(Ang));
+       Ogre::Vector2 Coords = Ogre::Vector2(Ogre::Math::Cos(Ang),
+       Ogre::Math::Sin(Ang));
 			Ang += 2*Ogre::Math::PI/3;
-			AmbientColor += mSkyX->getAtmosphereManager()->getColorAt(Ogre::Vector3(Coords.x, mOptions.Height/mSkyX->getMeshManager()->getSkydomeRadius(), Coords.y).normalisedCopy());
+       AmbientColor += mSkyX->getAtmosphereManager()->getColorAt(
+       Ogre::Vector3(Coords.x, mOptions.Height/mSkyX->getMeshManager()->
+       getSkydomeRadius(), Coords.y).normalisedCopy());
 		}
 
 		AmbientColor /= 3;
@@ -196,14 +241,16 @@
 		//}
 
 	//	mCloudLayerPass->getFragmentProgramParameters()
-	//		->setNamedConstant("uSunPosition", -SunDir*mSkyX->getMeshManager()->getSkydomeRadius());
+    //        ->setNamedConstant("uSunPosition",
+    //        -SunDir*mSkyX->getMeshManager()->getSkydomeRadius());
 
-		float point = (mSkyX->getController()->getSunDirection().y + 1.0f) / 2.0f;
+    float point = (mSkyX->getController()->getSunDirection().z + 1.0f) / 2.0f;
 
 		mCloudLayerPass->getFragmentProgramParameters()
 			->setNamedConstant("uSunColor", mSunGradient.getColor(point));
 		mCloudLayerPass->getFragmentProgramParameters()
-			->setNamedConstant("uAmbientLuminosity", mAmbientGradient.getColor(point));
+      ->setNamedConstant("uAmbientLuminosity",
+          mAmbientGradient.getColor(point));
 	}
 
 	/// ------------- CloudsManager ---------------
@@ -223,7 +270,8 @@
 
 		// TODO
 		NewCloudLayer->_registerCloudLayer(static_cast<Ogre::MaterialPtr>(
-			Ogre::MaterialManager::getSingleton().getByName(mSkyX->getGPUManager()->getSkydomeMaterialName()))
+          Ogre::MaterialManager::getSingleton().getByName(
+            mSkyX->getGPUManager()->getSkydomeMaterialName()))
 			->getTechnique(0)->createPass());
 
 		mCloudLayers.push_back(NewCloudLayer);
@@ -235,7 +283,8 @@
 		{
 			if (k+1 < mCloudLayers.size())
 			{
-				if (mCloudLayers.at(k)->getOptions().Height < mCloudLayers.at(k+1)->getOptions().Height)
+        if (mCloudLayers.at(k)->getOptions().Height <
+            mCloudLayers.at(k+1)->getOptions().Height)
 				{
 					// Swap
 					CloudLayer* cl = mCloudLayers.at(k);
@@ -259,7 +308,8 @@
 
 	void CloudsManager::remove(CloudLayer* cl)
 	{
-		for(CloudLayersIt = mCloudLayers.begin(); CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
+    for (CloudLayersIt = mCloudLayers.begin();
+        CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
         {
             if((*CloudLayersIt) == cl)
             {
@@ -272,7 +322,8 @@
 
 	void CloudsManager::removeAll()
 	{
-		for(CloudLayersIt = mCloudLayers.begin(); CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
+    for (CloudLayersIt = mCloudLayers.begin();
+        CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
         {
 			delete (*CloudLayersIt);
 		}
@@ -285,14 +336,16 @@
 		for(unsigned int k = 0; k < mCloudLayers.size(); k++)
 		{
 			mCloudLayers.at(k)->_registerCloudLayer(static_cast<Ogre::MaterialPtr>(
-				Ogre::MaterialManager::getSingleton().getByName(mSkyX->getGPUManager()->getSkydomeMaterialName()))
+            Ogre::MaterialManager::getSingleton().getByName(
+              mSkyX->getGPUManager()->getSkydomeMaterialName()))
 				->getTechnique(0)->createPass());
 		}
 	}
 
 	void CloudsManager::unregister(CloudLayer* cl)
 	{
-		for(CloudLayersIt = mCloudLayers.begin(); CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
+    for (CloudLayersIt = mCloudLayers.begin();
+        CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
         {
             if((*CloudLayersIt) == cl)
             {
@@ -303,7 +356,8 @@
 
 	void CloudsManager::unregisterAll()
 	{
-		for(CloudLayersIt = mCloudLayers.begin(); CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
+    for (CloudLayersIt = mCloudLayers.begin();
+        CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
         {
 			(*CloudLayersIt)->_unregister();
 		}
@@ -311,7 +365,8 @@
 
 	void CloudsManager::update()
 	{
-		for(CloudLayersIt = mCloudLayers.begin(); CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
+    for (CloudLayersIt = mCloudLayers.begin();
+        CloudLayersIt != mCloudLayers.end(); CloudLayersIt++)
         {
 			(*CloudLayersIt)->_updateInternalPassParameters();
 		}
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/ColorGradient.cpp	2012-03-08 20:30:44.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/ColorGradient.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <utility>
 #include "ColorGradient.h"
 
 namespace SkyX
@@ -58,7 +59,8 @@
 		minBound.second = -1;
 		for (unsigned int k = 0; k < CFrameVector.size(); k++)
 		{
-			if (CFrameVector.at(k).second < p && CFrameVector.at(k).second > minBound.second)
+      if (CFrameVector.at(k).second < p &&
+          CFrameVector.at(k).second > minBound.second)
 			{
 				minBound.first = k;
 				minBound.second = CFrameVector.at(k).second;
@@ -70,7 +72,8 @@
 		maxBound.second = 2;
 		for (unsigned int k = 0; k < CFrameVector.size(); k++)
 		{
-			if (CFrameVector.at(k).second > p && CFrameVector.at(k).second < maxBound.second)
+      if (CFrameVector.at(k).second > p &&
+          CFrameVector.at(k).second < maxBound.second)
 			{
 				maxBound.first = k;
 				maxBound.second = CFrameVector.at(k).second;
@@ -80,17 +83,19 @@
 		float range = maxBound.second - minBound.second,
 		      rangepoint = (p - minBound.second) / range;
 
-		return CFrameVector.at(minBound.first).first*(1-rangepoint) + CFrameVector.at(maxBound.first).first*rangepoint;
+    return CFrameVector.at(minBound.first).first*
+      (1-rangepoint) + CFrameVector.at(maxBound.first).first*rangepoint;
 	}
 
-	const bool ColorGradient::_checkBounds() const
+  bool ColorGradient::_checkBounds() const
 	{
 		std::pair<bool, bool> existbounds;
-		existbounds.first = false; existbounds.second = false;
+    existbounds.first = false;
+    existbounds.second = false;
 
 		for (unsigned int k = 0; k < CFrameVector.size(); k++)
 		{
-			if (CFrameVector.at(k).second == 0)
+      if (equal(CFrameVector.at(k).second, 0.0f))
 			{
 				// More than one min bound
 				if (existbounds.first)
@@ -109,7 +114,7 @@
 
 		for (unsigned int k = 0; k < CFrameVector.size(); k++)
 		{
-			if (CFrameVector.at(k).second == 1)
+      if (equal(CFrameVector.at(k).second, 1.0f))
 			{
 				// More than one min bound
 				if (existbounds.second)
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/GPUManager.cpp	2012-09-17 18:16:08.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/GPUManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "GPUManager.h"
 
 #include "SkyX.h"
@@ -28,8 +29,7 @@
 namespace SkyX
 {
 	GPUManager::GPUManager(SkyX *s)
-		: mSkyX(s)
-		, mGroundPasses(std::vector<Ogre::Pass*>())
+    : mSkyX(s), mGroundPasses(std::vector<Ogre::Pass*>())
 	{
 		_notifySkydomeMaterialChanged();
 	}
@@ -38,7 +38,9 @@
 	{
 	}
 
-	void GPUManager::addGroundPass(Ogre::Pass* GroundPass, const Ogre::Real& AtmosphereRadius, const Ogre::SceneBlendType& SBT)
+  void GPUManager::addGroundPass(Ogre::Pass* GroundPass,
+      const Ogre::Real& AtmosphereRadius,
+      const Ogre::SceneBlendType& SBT)
 	{
 		GroundPass->setVertexProgram("SkyX_Ground_VP");
 		if (mSkyX->getLightingMode() == SkyX::LM_LDR)
@@ -50,19 +52,23 @@
 			GroundPass->setFragmentProgram("SkyX_Ground_HDR_FP");
 		}
 
-		GroundPass->getVertexProgramParameters()->setNamedConstant("uSkydomeRadius", AtmosphereRadius*10);
+    GroundPass->getVertexProgramParameters()->setNamedConstant(
+        "uSkydomeRadius", AtmosphereRadius*10);
 
 		GroundPass->setLightingEnabled(false);
 		
 		GroundPass->setDepthCheckEnabled(true);
 		GroundPass->setDepthWriteEnabled(false);
 
+    GroundPass->setCullingMode(Ogre::CULL_NONE);
+
 		GroundPass->setSceneBlending(SBT);
 
 		/// TODO
         mGroundPasses.push_back(GroundPass);
 
-		mSkyX->getAtmosphereManager()->_update(mSkyX->getAtmosphereManager()->getOptions(), true);
+    mSkyX->getAtmosphereManager()->_update(
+        mSkyX->getAtmosphereManager()->getOptions(), true);
 	}
 
 	void GPUManager::_updateFP()
@@ -82,21 +88,29 @@
 		bool gammaCorrection = mSkyX->getLightingMode() == SkyX::LM_HDR;
 
 		// SkyX_Starfield.png
-		static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName(getSkydomeMaterialName()))
-			->getTechnique(0)->getPass(0)->getTextureUnitState(0)->setHardwareGammaEnabled(gammaCorrection);
+    static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName(
+          getSkydomeMaterialName()))->getTechnique(0)->getPass(0)
+      ->getTextureUnitState(0)->setHardwareGammaEnabled(gammaCorrection);
 
 		// SkyX_Moon.png and SkyX_MoonHalo.png
-		static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName(getMoonMaterialName()))
-			->getTechnique(0)->getPass(0)->getTextureUnitState(0)->setHardwareGammaEnabled(gammaCorrection);
-		static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName(getMoonMaterialName()))
-			->getTechnique(0)->getPass(0)->getTextureUnitState(1)->setHardwareGammaEnabled(gammaCorrection);
+    static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName(getMoonMaterialName()))
+      ->getTechnique(0)->getPass(0)->getTextureUnitState(0)
+      ->setHardwareGammaEnabled(gammaCorrection);
+    static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName(
+          getMoonMaterialName()))->getTechnique(0)->getPass(0)
+      ->getTextureUnitState(1)->setHardwareGammaEnabled(gammaCorrection);
 
 		_setTextureHWGammaCorrection("SkyX_Starfield.png", gammaCorrection);
 		_setTextureHWGammaCorrection("SkyX_Moon.png", gammaCorrection);
 		_setTextureHWGammaCorrection("SkyX_MoonHalo.png", gammaCorrection);
 	}
 
-	void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,  const Ogre::String &Name, const int &Value, const bool& UpdateGroundPasses)
+  void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,
+      const Ogre::String &Name, const int &Value,
+      const bool& UpdateGroundPasses)
 	{
 		if (!mSkyX->getMeshManager()->isCreated())
 		{
@@ -109,15 +123,19 @@
 		{
 		    case GPUP_VERTEX:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getVertexProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getVertexProgramParameters();
 			}
 			break;
 
 			case GPUP_FRAGMENT:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getFragmentProgramParameters();
 			}
 			break;
+      default:
+        break;
 		}
 
 		Parameters->setNamedConstant(Name, Value);
@@ -129,7 +147,8 @@
 
 		std::vector<Ogre::Pass*>::iterator PassIt;
 
-		for(PassIt = mGroundPasses.begin(); PassIt != mGroundPasses.end(); PassIt++)
+    for (PassIt = mGroundPasses.begin();
+         PassIt != mGroundPasses.end(); PassIt++)
 		{
 			if (!(*PassIt))
 			{
@@ -150,13 +169,17 @@
 					Parameters = (*PassIt)->getFragmentProgramParameters();
 				}
 				break;
+        default:
+          break;
 			}
 
 			Parameters->setNamedConstant(Name, Value);
 		}
 	}
 
-	void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,  const Ogre::String &Name, const Ogre::Real &Value, const bool& UpdateGroundPasses)
+  void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,
+      const Ogre::String &Name, const Ogre::Real &Value,
+      const bool& UpdateGroundPasses)
 	{
 		if (!mSkyX->getMeshManager()->isCreated())
 		{
@@ -169,15 +192,19 @@
 		{
 		    case GPUP_VERTEX:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getVertexProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getVertexProgramParameters();
 			}
 			break;
 
 			case GPUP_FRAGMENT:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getFragmentProgramParameters();
 			}
 			break;
+      default:
+        break;
 		}
 
 		Parameters->setNamedConstant(Name, Value);
@@ -189,7 +216,8 @@
 
 		std::vector<Ogre::Pass*>::iterator PassIt;
 
-		for(PassIt = mGroundPasses.begin(); PassIt != mGroundPasses.end(); PassIt++)
+    for (PassIt = mGroundPasses.begin();
+        PassIt != mGroundPasses.end(); PassIt++)
 		{
 			if (!(*PassIt))
 			{
@@ -210,13 +238,18 @@
 					Parameters = (*PassIt)->getFragmentProgramParameters();
 				}
 				break;
+
+        default:
+          break;
 			}
 
 			Parameters->setNamedConstant(Name, Value);
 		}
 	}
 
-	void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,  const Ogre::String &Name, const Ogre::Vector2 &Value, const bool& UpdateGroundPasses)
+  void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,
+      const Ogre::String &Name, const Ogre::Vector2 &Value,
+      const bool& UpdateGroundPasses)
 	{
 		if (!mSkyX->getMeshManager()->isCreated())
 		{
@@ -229,15 +262,19 @@
 		{
 		    case GPUP_VERTEX:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getVertexProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->
+            getVertexProgramParameters();
 			}
 			break;
 
 			case GPUP_FRAGMENT:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->
+            getFragmentProgramParameters();
 			}
 			break;
+      default:
+        break;
 		}
 
 		float Value_[2] = {Value.x, Value.y};
@@ -251,7 +288,8 @@
 
 		std::vector<Ogre::Pass*>::iterator PassIt;
 
-		for(PassIt = mGroundPasses.begin(); PassIt != mGroundPasses.end(); PassIt++)
+    for (PassIt = mGroundPasses.begin();
+         PassIt != mGroundPasses.end(); PassIt++)
 		{
 			if (!(*PassIt))
 			{
@@ -272,13 +310,17 @@
 					Parameters = (*PassIt)->getFragmentProgramParameters();
 				}
 				break;
+        default:
+          break;
 			}
 
 			Parameters->setNamedConstant(Name, Value_, 1, 2);
 		}
 	}
 
-	void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,  const Ogre::String &Name, const Ogre::Vector3 &Value, const bool& UpdateGroundPasses)
+  void GPUManager::setGpuProgramParameter(const GpuProgram &GpuP,
+      const Ogre::String &Name, const Ogre::Vector3 &Value,
+      const bool& UpdateGroundPasses)
 	{
 		if (!mSkyX->getMeshManager()->isCreated())
 		{
@@ -291,15 +333,19 @@
 		{
 		    case GPUP_VERTEX:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getVertexProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getVertexProgramParameters();
 			}
 			break;
 
 			case GPUP_FRAGMENT:
 			{
-				Parameters = mSkydomeMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
+          Parameters = mSkydomeMaterial->getTechnique(0)
+            ->getPass(0)->getFragmentProgramParameters();
 			}
 			break;
+      default:
+        break;
 		}
 
 		Parameters->setNamedConstant(Name, Value);
@@ -311,7 +357,8 @@
 
 		std::vector<Ogre::Pass*>::iterator PassIt;
 
-		for(PassIt = mGroundPasses.begin(); PassIt != mGroundPasses.end(); PassIt++)
+    for (PassIt = mGroundPasses.begin();
+         PassIt != mGroundPasses.end(); PassIt++)
 		{
 			if (!(*PassIt))
 			{
@@ -332,6 +379,8 @@
 					Parameters = (*PassIt)->getFragmentProgramParameters();
 				}
 				break;
+        default:
+          break;
 			}
 
 			Parameters->setNamedConstant(Name, Value);
@@ -342,10 +391,12 @@
 	{
 		Ogre::String starfield = (mSkyX->isStarfieldEnabled()) ? "STARFIELD_" : "";
 
-		return (mSkyX->getLightingMode() == SkyX::LM_LDR) ? "SkyX_Skydome_" + starfield + "LDR" : "SkyX_Skydome_" + starfield + "HDR";
+    return (mSkyX->getLightingMode() == SkyX::LM_LDR) ?
+      "SkyX_Skydome_" + starfield + "LDR" : "SkyX_Skydome_" + starfield + "HDR";
 	}
 
-	void GPUManager::_setTextureHWGammaCorrection(const Ogre::String& n, const bool& g)
+  void GPUManager::_setTextureHWGammaCorrection(const Ogre::String& n,
+      const bool& g)
 	{
 		Ogre::TexturePtr tex = Ogre::TextureManager::getSingleton().getByName(n);
 
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/MeshManager.cpp	2012-12-06 15:05:08.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/MeshManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -61,7 +61,8 @@
 		}
 
 		mSceneNode->detachAllObjects();
-		mSceneNode->getParentSceneNode()->removeAndDestroyChild(mSceneNode->getName());
+    mSceneNode->getParentSceneNode()->removeAndDestroyChild(
+        mSceneNode->getName());
 		mSceneNode = 0;
 
 		Ogre::MeshManager::getSingleton().remove("SkyXMesh");
@@ -102,12 +103,14 @@
         mMesh->load();
         mMesh->touch();
 
-        mEntity = mSkyX->getSceneManager()->createEntity("SkyXMeshEnt", "SkyXMesh");
+        mEntity = mSkyX->getSceneManager()->createEntity("SkyXMeshEnt",
+            "SkyXMesh");
         mEntity->setMaterialName(mMaterialName);
 		mEntity->setCastShadows(false);
 		mEntity->setRenderQueueGroup(mSkyX->getRenderQueueGroups().skydome);
 
-		mSceneNode = mSkyX->getSceneManager()->getRootSceneNode()->createChildSceneNode();
+    mSceneNode = mSkyX->getSceneManager()->getRootSceneNode()->
+      createChildSceneNode();
 		mSceneNode->showBoundingBox(false);
         mSceneNode->attachObject(mEntity);
 
@@ -123,9 +126,14 @@
 
 		float Radius = getSkydomeRadius(cam);
 
-		mVertices[0].x = 0; mVertices[0].z = 0;	mVertices[0].y = Radius;
-		mVertices[0].nx = 0; mVertices[0].nz = 0; mVertices[0].ny = 1; 
-		mVertices[0].u = 4; mVertices[0].v = 4;
+    mVertices[0].x = 0;
+    mVertices[0].z = Radius;
+    mVertices[0].y = 0;
+    mVertices[0].nx = 0;
+    mVertices[0].nz = 0;
+    mVertices[0].ny = 1;
+    mVertices[0].u = 4;
+    mVertices[0].v = 4;
 		mVertices[0].o = 1;
 
 		float AngleStep = (Ogre::Math::PI/2) / (mCircles-mUnderHorizonCircles);
@@ -152,8 +160,8 @@
 				s = Ogre::Math::Sin(currentPhiAngle) * r;
 
 				mVertices[1+y*mSteps + x].x = c * Radius;
-				mVertices[1+y*mSteps + x].z = s * Radius;
-				mVertices[1+y*mSteps + x].y = h * Radius;
+        mVertices[1+y*mSteps + x].y = s * Radius;
+        mVertices[1+y*mSteps + x].z = h * Radius;
 
 				mVertices[1+y*mSteps + x].nx = c;
 				mVertices[1+y*mSteps + x].nz = s;
@@ -178,7 +186,10 @@
 
 			uvr = static_cast<float>(y+1)/(mCircles-mUnderHorizonCircles);
 
-			op = Ogre::Math::Clamp<Ogre::Real>(Ogre::Math::Pow(static_cast<Ogre::Real>(mCircles-y-1) / mUnderHorizonCircles, mUnderHorizonFadingExponent)*mUnderHorizonFadingMultiplier, 0, 1);
+      op = Ogre::Math::Clamp<Ogre::Real>(
+          Ogre::Math::Pow(static_cast<Ogre::Real>(mCircles-y-1) /
+            mUnderHorizonCircles, mUnderHorizonFadingExponent)*
+          mUnderHorizonFadingMultiplier, 0, 1);
 
 			for(x=0;x<mSteps;x++) 
 			{
@@ -188,8 +199,8 @@
 				s = Ogre::Math::Sin(currentPhiAngle) * r;
 
 				mVertices[1+y*mSteps + x].x = c * Radius;
-				mVertices[1+y*mSteps + x].z = s * Radius;
-				mVertices[1+y*mSteps + x].y = h * Radius;
+        mVertices[1+y*mSteps + x].y = s * Radius;
+        mVertices[1+y*mSteps + x].z = h * Radius;
 
 				mVertices[1+y*mSteps + x].nx = c;
 				mVertices[1+y*mSteps + x].nz = s;
@@ -211,7 +222,7 @@
 	
 		// Update bounds
 	    Ogre::AxisAlignedBox meshBounds =
-			Ogre::AxisAlignedBox(-Radius, 0,     -Radius,
+      Ogre::AxisAlignedBox(-Radius, -Radius, 0,
 			                      Radius, Radius, Radius);
 
 		mMesh->_setBounds(meshBounds);
@@ -229,16 +240,20 @@
 		mSubMesh->vertexData->vertexCount = numVertices;
 
 		Ogre::VertexDeclaration* vdecl = mSubMesh->vertexData->vertexDeclaration;
-		Ogre::VertexBufferBinding* vbind = mSubMesh->vertexData->vertexBufferBinding;
+    Ogre::VertexBufferBinding* vbind =
+      mSubMesh->vertexData->vertexBufferBinding;
 
 		size_t offset = 0;
 		vdecl->addElement(0, offset, Ogre::VET_FLOAT3, Ogre::VES_POSITION);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT3);
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT3, Ogre::VES_TEXTURE_COORDINATES, 0);
+    vdecl->addElement(0, offset,
+        Ogre::VET_FLOAT3, Ogre::VES_TEXTURE_COORDINATES, 0);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT3);
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 1);
+    vdecl->addElement(0, offset,
+        Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 1);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT2);
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT1, Ogre::VES_TEXTURE_COORDINATES, 2);
+    vdecl->addElement(0, offset, Ogre::VET_FLOAT1,
+                      Ogre::VES_TEXTURE_COORDINATES, 2);
 
 		mVertexBuffer = Ogre::HardwareBufferManager::getSingleton().
 			createVertexBuffer(sizeof(VERTEX),
@@ -247,7 +262,7 @@
 
 		vbind->setBinding(0, mVertexBuffer);
 
-		unsigned short *indexbuffer = new unsigned short[numEle];
+    uint16_t *indexbuffer = new uint16_t[numEle];
 
 		for (int k = 0; k < mSteps; k++)
 		{
@@ -264,7 +279,7 @@
 			}
 		}
 
-		unsigned short *twoface;
+    uint16_t *twoface;
 
 		for(int y=0; y<mCircles-1; y++) 
 		{
@@ -331,7 +346,10 @@
 		}
 	}
 
-	void MeshManager::setUnderHorizonParams(const int& UnderHorizonCircles, const bool& UnderHorizonFading, const Ogre::Real& UnderHorizonFadingExponent, const Ogre::Real& UnderHorizonFadingMultiplier)
+  void MeshManager::setUnderHorizonParams(const int& UnderHorizonCircles,
+      const bool& UnderHorizonFading,
+      const Ogre::Real& UnderHorizonFadingExponent,
+      const Ogre::Real& UnderHorizonFadingMultiplier)
 	{
 		bool needToRecreate = (mUnderHorizonCircles != UnderHorizonCircles);
 
@@ -357,11 +375,11 @@
 		}
 	}
 
-	const float MeshManager::getSkydomeRadius(Ogre::Camera* c) const
+  float MeshManager::getSkydomeRadius(Ogre::Camera* c) const
 	{
 		float cameraFarClipDistance = c->getFarClipDistance();
 
-		if (!cameraFarClipDistance)
+    if (equal(cameraFarClipDistance, 0.0f))
 		{
 			cameraFarClipDistance = mSkyX->getInfiniteCameraFarClipDistance();
 		}
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/MoonManager.cpp	2012-12-06 17:20:18.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/MoonManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -36,6 +36,7 @@
 		, mMoonHaloIntensity(0.4f)
 		, mMoonHaloStrength(0.9f)
 		, mMoonMaterial(Ogre::MaterialPtr())
+      , mVisible(true)
 	{
 	}
 
@@ -51,7 +52,8 @@
 			return;
 		}
 
-		mMoonMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("SkyX_Moon"));
+    mMoonMaterial = static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName("SkyX_Moon"));
 
 		if (mMoonMaterial.isNull())
 		{
@@ -59,12 +61,16 @@
 			return;
 		}
 
-		mMoonSceneNode = mSkyX->getSceneManager()->getRootSceneNode()->createChildSceneNode();
+    mMoonSceneNode = mSkyX->getSceneManager()->getRootSceneNode()->
+                     createChildSceneNode();
 
-		mMoonBillboard = mSkyX->getSceneManager()->createBillboardSet("SkyXMoonBillboardSet", 1);
-        mMoonBillboard->setMaterialName(mSkyX->getGPUManager()->getMoonMaterialName());
+    mMoonBillboard = mSkyX->getSceneManager()->createBillboardSet(
+        "SkyXMoonBillboardSet", 1);
+    mMoonBillboard->setMaterialName(
+        mSkyX->getGPUManager()->getMoonMaterialName());
 		mMoonBillboard->setBillboardType(Ogre::BBT_ORIENTED_COMMON);
-		mMoonBillboard->setRenderQueueGroup(mSkyX->getRenderQueueGroups().skydome+1);
+    mMoonBillboard->setRenderQueueGroup(
+        mSkyX->getRenderQueueGroups().skydome+1);
 		mMoonBillboard->setCastShadows(false);
 
 		mMoonBillboard->createBillboard(Ogre::Vector3(0,0,0));
@@ -82,7 +88,8 @@
 		}
 
 		mMoonSceneNode->detachAllObjects();
-		mMoonSceneNode->getParentSceneNode()->removeAndDestroyChild(mMoonSceneNode->getName());
+    mMoonSceneNode->getParentSceneNode()->removeAndDestroyChild(
+        mMoonSceneNode->getName());
 		mMoonSceneNode = 0;
 
 		mSkyX->getSceneManager()->destroyBillboardSet(mMoonBillboard);
@@ -95,7 +102,8 @@
 
 	void MoonManager::updateMoonPhase(const Ogre::Real& phase)
 	{
-		Ogre::Real center = 0, radius = 0, radius_add = 0, interpolation = 0, halo_flip = 0;
+    Ogre::Real center = 0, radius = 0, radius_add = 0;
+    Ogre::Real interpolation = 0, halo_flip = 0;
 
 		Ogre::Vector3 halo1, halo2;
 
@@ -254,14 +262,21 @@
 			}
 		}
 
-		mMoonMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uMoonPhase", Ogre::Vector3(radius, center + 0.5f, mMoonHaloStrength));
+    mMoonMaterial->getTechnique(0)->getPass(0)
+      ->getFragmentProgramParameters()->setNamedConstant(
+          "uMoonPhase", Ogre::Vector3(radius, center + 0.5f,
+            mMoonHaloStrength));
 
 		halo1.z *= mMoonHaloIntensity;
 		halo2.z *= mMoonHaloIntensity;
 
-		mMoonMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uMoonHalo1", halo1);
-		mMoonMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uMoonHalo2", halo2);
-		mMoonMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uMoonHaloFlip", halo_flip);
+    mMoonMaterial->getTechnique(0)->getPass(0)
+      ->getFragmentProgramParameters()->setNamedConstant("uMoonHalo1", halo1);
+    mMoonMaterial->getTechnique(0)->getPass(0)
+      ->getFragmentProgramParameters()->setNamedConstant("uMoonHalo2", halo2);
+    mMoonMaterial->getTechnique(0)->getPass(0)
+      ->getFragmentProgramParameters()->setNamedConstant("uMoonHaloFlip",
+          halo_flip);
 	}
 
 	void MoonManager::updateGeometry(Ogre::Camera* c)
@@ -274,14 +289,16 @@
 		float radius = mSkyX->getMeshManager()->getSkydomeRadius(c)*0.95f,
               size = radius*mMoonSize;
 
-		mMoonBillboard->setCommonDirection((mSkyX->getController()->getMoonDirection()).normalisedCopy().perpendicular());
+    mMoonBillboard->setCommonDirection((mSkyX->getController()->
+          getMoonDirection()).normalisedCopy().perpendicular());
 
-		Ogre::Vector3 moonRelativePos = mSkyX->getController()->getMoonDirection()*
+    Ogre::Vector3 moonRelativePos = mSkyX->getController()->
+      getMoonDirection()*
 			Ogre::Math::Cos(Ogre::Math::ASin((size/2)/radius))*radius;
 
 		mMoonSceneNode->setPosition(c->getDerivedPosition() + moonRelativePos);
 
-		if (moonRelativePos.y < -size/2)
+    if (moonRelativePos.z < -size/2)
 		{
 			mMoonSceneNode->setVisible(false);
 		}
@@ -290,10 +307,11 @@
 			mMoonSceneNode->setVisible(mSkyX->isVisible());
 
 			mMoonMaterial->getTechnique(0)->getPass(0)
-				->getVertexProgramParameters()->setNamedConstant("uSkydomeCenter", c->getDerivedPosition());
+        ->getVertexProgramParameters()->setNamedConstant(
+            "uSkydomeCenter", c->getDerivedPosition());
 		}
 
-		if (mMoonBillboard->getBoundingBox().getMaximum().x != size)
+    if (!equal(mMoonBillboard->getBoundingBox().getMaximum().x, size))
 		{
 			_updateMoonBounds(c);
 		}
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/Prerequisites.cpp	2012-03-08 20:30:44.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/Prerequisites.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -25,5 +25,4 @@
 
 namespace SkyX
 {
-
 }
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/SkyX.cpp	2012-12-27 00:34:30.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/SkyX.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,7 +21,9 @@
 --------------------------------------------------------------------------------
 */
 
+#ifdef _MSC_VER
 #pragma warning(disable:4355)
+#endif
 
 #include "SkyX.h"
 
@@ -30,6 +32,8 @@
 	SkyX::SkyX(Ogre::SceneManager* sm, Controller* c)
 		: Ogre::FrameListener()
 		, Ogre::RenderTargetListener()
+      , mStarfield(true)
+      , mLightingMode(LM_LDR)
 		, mSceneManager(sm)
 		, mController(c)
 		, mCamera(0)
@@ -38,16 +42,19 @@
 		, mGPUManager(new GPUManager(this))
 		, mMoonManager(new MoonManager(this))
 		, mCloudsManager(new CloudsManager(this))
-		, mRenderQueueGroups(RenderQueueGroups(Ogre::RENDER_QUEUE_SKIES_EARLY, Ogre::RENDER_QUEUE_3, Ogre::RENDER_QUEUE_4, Ogre::RENDER_QUEUE_2))
+      , mRenderQueueGroups(RenderQueueGroups(Ogre::RENDER_QUEUE_SKIES_EARLY,
+            Ogre::RENDER_QUEUE_3,
+            Ogre::RENDER_QUEUE_4))
 		, mCreated(false)
 		, mLastCameraPosition(Ogre::Vector3(0,0,0))
 		, mLastCameraFarClipDistance(-1)
 		, mInfiniteCameraFarClipDistance(100000)
 		, mVisible(true)
-		, mLightingMode(LM_LDR)
-		, mStarfield(true)
 		, mTimeMultiplier(0.1f)
 		, mTimeOffset(0.0f)
+      , mMoonEnabled(true)
+      , mCloudsEnabled(true)
+      , mEnabled(true)
 	{
 		// Need to be instanced here, when SkyX::mSceneManager is valid
 		mVCloudsManager = new VCloudsManager(this);
@@ -86,11 +93,21 @@
 
 		if (mStarfield)
 		{
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uTime", mTimeOffset*0.5f, false);
+      mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT,
+                                          "uTime", mTimeOffset*0.5f, false);
 		}
 
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uLightDir", mController->getSunDirection());
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uLightDir", mController->getSunDirection());
+    Ogre::Vector3 sunDir = mController->getSunDirection();
+
+    // Z-up conversion
+    Ogre::Real ydir = sunDir.y;
+    sunDir.y = sunDir.z;
+    sunDir.z = ydir;
+
+    mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX,
+        "uLightDir", sunDir);
+    mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT,
+        "uLightDir", sunDir);
 
 		mMoonManager->create();
 
@@ -99,6 +116,10 @@
 		mLastCameraPosition = Ogre::Vector3(0,0,0);
 		mLastCameraFarClipDistance = -1;
 
+    // FIXME: Disable mMoonManager otherwise gpu range values get clipped.
+    // issue #678
+    mMoonManager->getMoonSceneNode()->setVisible(false);
+
 		mCreated = true;
 	}
 
@@ -121,12 +142,12 @@
 
 	void SkyX::update(const Ogre::Real& timeSinceLastFrame)
 	{
-		if (!mCreated)
+    if (!mCreated || !this->mEnabled)
 		{
 			return;
 		}
 
-		if (mTimeMultiplier != 0)
+    if (!equal(mTimeMultiplier, 0.0f))
 		{
 			float timemultiplied = timeSinceLastFrame * mTimeMultiplier;
 
@@ -136,21 +157,35 @@
 
 			if (mStarfield)
 			{
-				mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uTime", mTimeOffset*0.5f, false);
+        mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT,
+            "uTime", mTimeOffset*0.5f, false);
 			}
 		}
 
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uLightDir", mController->getSunDirection());
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uLightDir", mController->getSunDirection());
+    Ogre::Vector3 sunDir = mController->getSunDirection();
+
+    // Z-up conversion
+    Ogre::Real ydir = sunDir.y;
+    sunDir.y = sunDir.z;
+    sunDir.z = ydir;
+
+    mGPUManager->setGpuProgramParameter(
+        GPUManager::GPUP_VERTEX, "uLightDir", sunDir);
+    mGPUManager->setGpuProgramParameter(
+        GPUManager::GPUP_FRAGMENT, "uLightDir", sunDir);
 
+    if (this->mMoonEnabled)
 		mMoonManager->updateMoonPhase(mController->getMoonPhase());
+    if (this->mCloudsEnabled)
+    {
 		mCloudsManager->update();
 		mVCloudsManager->update(timeSinceLastFrame);
 	}
+  }
 
 	void SkyX::notifyCameraRender(Ogre::Camera* c)
 	{
-		if (!mCreated)
+    if (!mCreated || !this->mEnabled)
 		{
 			return;
 		}
@@ -164,17 +199,20 @@
 			mLastCameraPosition = mCamera->getDerivedPosition();
 		}
 
-		if (mLastCameraFarClipDistance != c->getFarClipDistance())
+    if (!equal(mLastCameraFarClipDistance, c->getFarClipDistance()))
 		{
 			mMeshManager->updateGeometry(c);
 
 			mLastCameraFarClipDistance = mCamera->getFarClipDistance();
 		}
 
+    if (this->mMoonEnabled)
 		mMoonManager->updateGeometry(c);
-
+    if (this->mCloudsEnabled)
+    {
 		mVCloudsManager->notifyCameraRender(c);
 	}
+  }
 
 	void SkyX::setVisible(const bool& visible)
 	{
@@ -186,7 +224,9 @@
 		}
 
 		mMeshManager->getSceneNode()->setVisible(mVisible);
-		mMoonManager->getMoonSceneNode()->setVisible(mVisible);
+
+    // Disable moon manager as it clips gpu laser range values
+    // mMoonManager->getMoonSceneNode()->setVisible(mVisible);
 
 		if (mVCloudsManager->isCreated())
 		{
@@ -199,7 +239,8 @@
 		mRenderQueueGroups = rqg;
 
 		mVCloudsManager->getVClouds()->setRenderQueueGroups(
-			VClouds::VClouds::RenderQueueGroups(mRenderQueueGroups.vclouds, mRenderQueueGroups.vcloudsLightningsUnder, mRenderQueueGroups.vcloudsLightningsOver));
+        VClouds::VClouds::RenderQueueGroups(
+          mRenderQueueGroups.vclouds, mRenderQueueGroups.vcloudsLightnings));
 
 		if (!mCreated)
 		{
@@ -207,7 +248,8 @@
 		}
 
 		mMeshManager->getEntity()->setRenderQueueGroup(mRenderQueueGroups.skydome);
-		mMoonManager->getMoonBillboard()->setRenderQueueGroup(mRenderQueueGroups.skydome+1);
+    mMoonManager->getMoonBillboard()->setRenderQueueGroup(
+        mRenderQueueGroups.skydome+1);
 	}
 
 	void SkyX::setLightingMode(const LightingMode& lm)
@@ -251,11 +293,21 @@
 
 		if (mStarfield)
 		{
-			mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uTime", mTimeOffset*0.5f, false);
+      mGPUManager->setGpuProgramParameter(
+          GPUManager::GPUP_FRAGMENT, "uTime", mTimeOffset*0.5f, false);
 		}
 
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_VERTEX, "uLightDir", mController->getSunDirection());
-		mGPUManager->setGpuProgramParameter(GPUManager::GPUP_FRAGMENT, "uLightDir", mController->getSunDirection());
+    Ogre::Vector3 sunDir = mController->getSunDirection();
+
+    // Z-up conversion
+    Ogre::Real ydir = sunDir.y;
+    sunDir.y = sunDir.z;
+    sunDir.z = ydir;
+
+    mGPUManager->setGpuProgramParameter(
+        GPUManager::GPUP_VERTEX, "uLightDir", sunDir);
+    mGPUManager->setGpuProgramParameter(
+        GPUManager::GPUP_FRAGMENT, "uLightDir", sunDir);
 	}
 
 	bool SkyX::frameStarted(const Ogre::FrameEvent& e)
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/DataManager.cpp	2012-03-08 20:29:48.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/DataManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "VClouds/DataManager.h"
 
 #include "VClouds/VClouds.h"
@@ -91,7 +92,8 @@
 			{
 				for (int k = mStep; k <= mXEnd/mNx; k++)
 				{
-					_performCalculations(mNx, mNy, mNz, k, mXStart%mNx, (mXEnd/mNx != k) ? mNx : mXEnd%mNx);
+          _performCalculations(mNx, mNy, mNz, k, mXStart%mNx,
+              (mXEnd/mNx != k) ? mNx : mXEnd%mNx);
 					mXStart = 0;
 				}
 			}
@@ -99,7 +101,8 @@
 			{
 				if (mXStart != mXEnd)
 				{
-					_performCalculations(mNx, mNy, mNz, mXEnd/mNx, mXStart%mNx, mXEnd%mNx);
+          _performCalculations(mNx, mNy, mNz, mXEnd/mNx,
+              mXStart%mNx, mXEnd%mNx);
 				}
 			}
 
@@ -119,7 +122,8 @@
 		{
 			mCurrentTransition -= timeSinceLastFrame;
 
-			mXEnd = static_cast<int>(((mUpdateTime-mCurrentTransition) / mUpdateTime)*4*mNx);
+      mXEnd = static_cast < int>(((mUpdateTime-mCurrentTransition) /
+            mUpdateTime)*4*mNx);
 			if (mXEnd < 0)
 			{
 				mXEnd = 0;
@@ -129,7 +133,8 @@
 			{
 				for (int k = mStep; k <= mXEnd/mNx; k++)
 				{
-					_performCalculations(mNx, mNy, mNz, k, mXStart%mNx, (mXEnd/mNx != k) ? mNx : mXEnd%mNx);
+          _performCalculations(mNx, mNy, mNz, k, mXStart%mNx,
+              (mXEnd/mNx != k) ? mNx : mXEnd%mNx);
 					mXStart = 0;
 				}
 			}
@@ -137,7 +142,8 @@
 			{
 				if (mXStart != mXEnd)
 				{
-					_performCalculations(mNx, mNy, mNz, mXEnd/mNx, mXStart%mNx, mXEnd%mNx);
+          _performCalculations(mNx, mNy, mNz, mXEnd/mNx,
+              mXStart%mNx, mXEnd%mNx);
 				}
 			}
 
@@ -159,7 +165,9 @@
 	{
 		remove();
 
-		mNx = nx; mNy = ny; mNz = nz;
+    mNx = nx;
+    mNy = ny;
+    mNz = nz;
 
 		mFFRandom = new FastFakeRandom(1024, 0, 1);
 
@@ -206,7 +214,8 @@
 		mCellsTmp     = _create3DCellArray(nx, ny, nz, false);
 	}
 
-	DataManager::Cell *** DataManager::_create3DCellArray(const int& nx, const int& ny, const int& nz, const bool& init)
+  DataManager::Cell *** DataManager::_create3DCellArray(const int& nx,
+      const int& ny, const int& nz, const bool& init)
 	{
 		Cell ***c = new Cell** [nx];
 
@@ -267,7 +276,8 @@
 		delete [] c;
 	}
 
-	void DataManager::_copy3DCellArraysData(Cell ***src, Cell ***dest, const int& nx, const int& ny, const int& nz)
+  void DataManager::_copy3DCellArraysData(Cell ***src, Cell ***dest,
+      const int& nx, const int& ny, const int& nz)
 	{
 		int u, v, w;
 
@@ -292,38 +302,51 @@
 		}
 	}
 
-	void DataManager::setWheater(const float& Humidity, const float& AverageCloudsSize, const bool& delayedResponse)
+  void DataManager::setWheater(const float& Humidity,
+      const float& AverageCloudsSize, const bool& delayedResponse)
 	{
 		int numberofclouds = static_cast<int>(Humidity * mMaxNumberOfClouds);
-		Ogre::Vector3 maxcloudsize = AverageCloudsSize*Ogre::Vector3(mNx/14, mNy/14, static_cast<int>(static_cast<float>(mNz)/2.75));
+    Ogre::Vector3 maxcloudsize = AverageCloudsSize*
+      Ogre::Vector3(mNx/14, mNy/14,
+          static_cast < int>(static_cast < float>(mNz)/2.75));
 
 		// Update old clouds with new parameters
 		Ogre::Vector3 currentdimensions, currentPosition;
 		std::vector<Ellipsoid*>::const_iterator mEllipsoidsIt;
 
-		for(mEllipsoidsIt = mEllipsoids.begin(); mEllipsoidsIt != mEllipsoids.end(); mEllipsoidsIt++)
+    for (mEllipsoidsIt = mEllipsoids.begin();
+        mEllipsoidsIt != mEllipsoids.end(); mEllipsoidsIt++)
 		{
 			// Update size
 			currentdimensions = (*mEllipsoidsIt)->getDimensions();
 
-			if (currentdimensions.x / maxcloudsize.x < 0.5 || currentdimensions.x / maxcloudsize.x > 2)
+      if (currentdimensions.x / maxcloudsize.x < 0.5 ||
+          currentdimensions.x / maxcloudsize.x > 2)
 			{
-				currentdimensions.x = maxcloudsize.x + Ogre::Math::RangeRandom(-0.2,0.2)*maxcloudsize.x;
+        currentdimensions.x = maxcloudsize.x +
+          Ogre::Math::RangeRandom(-0.2, 0.2)*maxcloudsize.x;
 			}
-			if (currentdimensions.y / maxcloudsize.y < 0.5 || currentdimensions.y / maxcloudsize.y > 2)
+      if (currentdimensions.y / maxcloudsize.y < 0.5 ||
+          currentdimensions.y / maxcloudsize.y > 2)
 			{
-				currentdimensions.y = maxcloudsize.y + Ogre::Math::RangeRandom(-0.2,0.2)*maxcloudsize.y;
+        currentdimensions.y = maxcloudsize.y +
+          Ogre::Math::RangeRandom(-0.2, 0.2)*maxcloudsize.y;
 			}
-			if (currentdimensions.z / maxcloudsize.z < 0.5 || currentdimensions.z / maxcloudsize.z > 2)
+      if (currentdimensions.z / maxcloudsize.z < 0.5 ||
+          currentdimensions.z / maxcloudsize.z > 2)
 			{
-				currentdimensions.z = maxcloudsize.z + Ogre::Math::RangeRandom(-0.2,0.15)*maxcloudsize.z;
+        currentdimensions.z = maxcloudsize.z +
+          Ogre::Math::RangeRandom(-0.2, 0.15)*maxcloudsize.z;
 			}
 
 			(*mEllipsoidsIt)->setDimensions(currentdimensions);
 
 			// Update position
 			currentPosition = (*mEllipsoidsIt)->getPosition();
-			(*mEllipsoidsIt)->setPosition(Ogre::Vector3(currentPosition.x,currentPosition.y,static_cast<int>(Ogre::Math::RangeRandom(currentdimensions.z+2,mNz-currentdimensions.z-2))));
+      (*mEllipsoidsIt)->setPosition(
+          Ogre::Vector3(currentPosition.x, currentPosition.y,
+            static_cast < int>(Ogre::Math::RangeRandom(currentdimensions.z+2,
+                mNz-currentdimensions.z-2))));
 		}
 
 		// Remove some clouds if needed
@@ -336,8 +359,17 @@
 		Ogre::Vector3 newclouddimensions;
 		while (static_cast<unsigned int>(numberofclouds) > mEllipsoids.size())
 		{
-			newclouddimensions = maxcloudsize*Ogre::Vector3(Ogre::Math::RangeRandom(0.5, 2), Ogre::Math::RangeRandom(0.5, 2), Ogre::Math::RangeRandom(0.75, 1));
-			addEllipsoid(new Ellipsoid(newclouddimensions.x,  newclouddimensions.y,  newclouddimensions.z, mNx, mNy, mNz, (int)Ogre::Math::RangeRandom(0, mNx), (int)Ogre::Math::RangeRandom(0, mNy), static_cast<int>(Ogre::Math::RangeRandom(newclouddimensions.z+2,mNz-newclouddimensions.z-2)), Ogre::Math::RangeRandom(1,5.0f)), false);
+      newclouddimensions = maxcloudsize *
+        Ogre::Vector3(Ogre::Math::RangeRandom(0.5, 2),
+            Ogre::Math::RangeRandom(0.5, 2), Ogre::Math::RangeRandom(0.75, 1));
+
+      addEllipsoid(new Ellipsoid(newclouddimensions.x, newclouddimensions.y,
+            newclouddimensions.z, mNx, mNy, mNz,
+            (int)Ogre::Math::RangeRandom(0, mNx),
+            (int)Ogre::Math::RangeRandom(0, mNy),
+            static_cast < int>(Ogre::Math::RangeRandom(
+                newclouddimensions.z+2, mNz-newclouddimensions.z-2)),
+            Ogre::Math::RangeRandom(1, 5.0f)), false);
 		}
 
 		_updateProbabilities(mCellsCurrent, mNx, mNy, mNz, delayedResponse);
@@ -365,7 +397,8 @@
 		}
 	}
 
-	void DataManager::_clearProbabilities(Cell*** c, const int& nx, const int& ny, const int& nz, const bool& clearData)
+  void DataManager::_clearProbabilities(Cell*** c, const int& nx,
+      const int& ny, const int& nz, const bool& clearData)
 	{
 		int u, v, w;
 
@@ -393,41 +426,59 @@
 		}
 	}
 
-	void DataManager::_updateProbabilities(Cell*** c, const int& nx, const int& ny, const int& nz, const bool& delayedResponse)
+  void DataManager::_updateProbabilities(Cell*** c, const int& nx,
+      const int& ny, const int& nz, const bool& delayedResponse)
 	{
 		_clearProbabilities(c,nx,ny,nz,!delayedResponse);
 
 		std::vector<Ellipsoid*>::const_iterator mEllipsoidsIt;
 
-		for(mEllipsoidsIt = mEllipsoids.begin(); mEllipsoidsIt != mEllipsoids.end(); mEllipsoidsIt++)
+    for (mEllipsoidsIt = mEllipsoids.begin();
+        mEllipsoidsIt != mEllipsoids.end(); mEllipsoidsIt++)
 		{
 			(*mEllipsoidsIt)->updateProbabilities(c,nx,ny,nz,delayedResponse);
 		}
 	}
 
-	const Ogre::Real DataManager::_getLightAbsorcionAt(Cell*** c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z, const Ogre::Vector3& d, const float& att) const
+  Ogre::Real DataManager::_getLightAbsorcionAt(Cell*** c, const int& nx,
+      const int& ny, const int& nz, const int& x, const int& y, const int& z,
+      const Ogre::Vector3& d, const float& att) const
 	{
 		Ogre::Real step = 1, factor = 1;
-		Ogre::Vector3 pos = Ogre::Vector3(x, y, z);
+    Ogre::Vector3 negD = -d;
+    int xLocal = x;
+    int yLocal = y;
+    int zLocal = z;
 		bool outOfBounds = false;
 		int u, v, uu, vv,
 		    current_iteration = 0, max_iterations = 8;
 
 		while(!outOfBounds)
 		{
-			if ( (int)pos.z >= nz || (int)pos.z < 0 || factor <= 0 || current_iteration >= max_iterations)
+      if (zLocal >= nz || zLocal < 0 || factor <= 0 ||
+          current_iteration >= max_iterations)
 			{
 				outOfBounds = true;
 			}
 			else
 			{
-				u = (int)pos.x; v = (int)pos.y;
+        u = xLocal;
+        v = yLocal;
 
-				uu = (u<0) ? (u + nx) : u; if (u>=nx) { uu-= nx; }
-				vv = (v<0) ? (v + ny) : v; if (v>=ny) { vv-= ny; }
-
-				factor -= c[uu][vv][(int)pos.z].dens*att*(1-static_cast<float>(current_iteration)/max_iterations);
-				pos += step*(-d);
+        uu = (u < 0) ? (u + nx) : u;
+        if (u >= nx)
+          uu -= nx;
+
+        vv = (v < 0) ? (v + ny) : v;
+        if (v >= ny)
+          vv -= ny;
+
+        factor -= c[uu][vv][zLocal].dens * att * (1 -
+            static_cast<float>(current_iteration)/max_iterations);
+
+        xLocal += step * negD.x;
+        yLocal += step * negD.y;
+        zLocal += step * negD.z;
 
 				current_iteration++;
 			}
@@ -436,7 +487,8 @@
 		return Ogre::Math::Clamp<Ogre::Real>(factor,0,1);
 	}
 
-	void DataManager::_performCalculations(const int& nx, const int& ny, const int& nz, const int& step, const int& xStart, const int& xEnd)
+  void DataManager::_performCalculations(const int& nx, const int& ny,
+      const int& nz, const int& step, const int& xStart, const int& xEnd)
 	{
 		int u, v, w;
 
@@ -451,9 +503,12 @@
 						for (w = 0; w < nz; w++)
 						{
 							// ti+1                       ti
-							mCellsCurrent[u][v][w].hum = mCellsCurrent[u][v][w].hum || (mFFRandom->get() < mCellsCurrent[u][v][w].phum);
-							mCellsCurrent[u][v][w].cld = mCellsCurrent[u][v][w].cld && (mFFRandom->get() > mCellsCurrent[u][v][w].pext);
-							mCellsCurrent[u][v][w].act = mCellsCurrent[u][v][w].act || (mFFRandom->get() < mCellsCurrent[u][v][w].pact);
+                mCellsCurrent[u][v][w].hum = mCellsCurrent[u][v][w].hum ||
+                  (mFFRandom->get() < mCellsCurrent[u][v][w].phum);
+                mCellsCurrent[u][v][w].cld = mCellsCurrent[u][v][w].cld &&
+                  (mFFRandom->get() > mCellsCurrent[u][v][w].pext);
+                mCellsCurrent[u][v][w].act = mCellsCurrent[u][v][w].act ||
+                  (mFFRandom->get() < mCellsCurrent[u][v][w].pact);
 
 							// Copy act in the temporal buffer, for _fact(...)
 							mCellsTmp[u][v][w].act = mCellsCurrent[u][v][w].act;
@@ -471,9 +526,13 @@
 						for (w = 0; w < nz; w++)
 						{
 							// ti+1                       ti
-							mCellsCurrent[u][v][w].hum =  mCellsCurrent[u][v][w].hum && !mCellsCurrent[u][v][w].act;
-							mCellsCurrent[u][v][w].cld =  mCellsCurrent[u][v][w].cld ||  mCellsCurrent[u][v][w].act;
-							mCellsCurrent[u][v][w].act = !mCellsCurrent[u][v][w].act &&  mCellsCurrent[u][v][w].hum && _fact(mCellsTmp, nx, ny, nz, u,v,w);
+                mCellsCurrent[u][v][w].hum =  mCellsCurrent[u][v][w].hum &&
+                  !mCellsCurrent[u][v][w].act;
+                mCellsCurrent[u][v][w].cld =  mCellsCurrent[u][v][w].cld ||
+                  mCellsCurrent[u][v][w].act;
+                mCellsCurrent[u][v][w].act = !mCellsCurrent[u][v][w].act &&
+                  mCellsCurrent[u][v][w].hum &&
+                  _fact(mCellsTmp, nx, ny, nz, u, v, w);
 						}
 					}
 				}
@@ -488,8 +547,10 @@
 					{
 						for (w = 0; w < nz; w++)
 						{
-						   mCellsCurrent[u][v][w].dens = _getDensityAt(mCellsCurrent, nx, ny, nz, u,v,w, 1/*TODOOOO!!!*/, 1.15f);
-						  // mCellsCurrent[u][v][w].dens = _getDensityAt(mCellsCurrent,u,v,w);
+                mCellsCurrent[u][v][w].dens = _getDensityAt(mCellsCurrent,
+                    nx, ny, nz, u, v, w, 1/*TODOOOO!!!*/, 1.15f);
+                // mCellsCurrent[u][v][w].dens =
+                // _getDensityAt(mCellsCurrent,u,v,w);
 						}
 					}
 				}
@@ -498,7 +559,8 @@
 			case 3:
 			{
 				// Light scattering
-				Ogre::Vector3 SunDir = Ogre::Vector3(mVClouds->getSunDirection().x, mVClouds->getSunDirection().z, mVClouds->getSunDirection().y);
+          Ogre::Vector3 SunDir = Ogre::Vector3(mVClouds->getSunDirection().x,
+              mVClouds->getSunDirection().y, mVClouds->getSunDirection().z);
 
 				for (u = xStart; u < xEnd; u++)
 				{
@@ -506,16 +568,21 @@
 					{
 						for (w = 0; w < nz; w++)
 						{
-							mCellsCurrent[u][v][w].light = _getLightAbsorcionAt(mCellsCurrent, nx, ny, nz, u,v,w, SunDir, 0.15f/*TODO!!!!*/);
+                mCellsCurrent[u][v][w].light = _getLightAbsorcionAt(
+                    mCellsCurrent, nx, ny, nz, u, v, w, SunDir,
+                    0.15f/*TODO!!!!*/);
 						}
 					}
 				}
 			}
 			break;
+      default:
+        break;
 		}
 	}
 
-	const bool DataManager::_fact(Cell ***c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z) const
+  bool DataManager::_fact(Cell ***c, const int& nx, const int& ny,
+      const int& nz, const int& x, const int& y, const int& z) const
 	{
 		bool i1m, j1m, k1m, 
 			 i1r, j1r, k1r, 
@@ -536,15 +603,18 @@
 		i2m = ((x+2)>=nx) ? c[1][y][z].act : c[x+2][y][z].act;
 		j2m = ((y+2)>=ny) ? c[x][1][z].act : c[x][y+2][z].act;
 
-		return i1m || j1m || k1m  || i1r || j1r || k1r || i2r || i2m || j2r || j2m || k2r;
+    return i1m || j1m || k1m || i1r || j1r || k1r || i2r ||
+           i2m || j2r || j2m || k2r;
 	}
 
-	const float DataManager::_getDensityAt(Cell ***c, const int& nx, const int& ny, const int& nz, const int& x, const int& y, const int& z, const int& r, const float& strength) const
-	{		
-		int zr = ((z-r)<0) ? 0 : z-r,
-			zm = ((z+r)>=nz) ? nz : z+r,
-            u, uu, v, vv, w, 
-			clouds = 0, div = 0;
+  float DataManager::_getDensityAt(Cell ***c, const int& nx,
+      const int& ny, const int& nz, const int& x, const int& y, const int& z,
+      const int& r, const float& strength) const
+  {
+    int zr = ((z-r) < 0) ? 0 : z-r;
+    int zm = ((z+r) >= nz) ? nz : z+r;
+    int u, uu, v, vv, w;
+    int clouds = 0, div = 0;
 
 		for (u = x-r; u <= x+r; u++)
 		{
@@ -553,8 +623,10 @@
 				for (w = zr; w < zm; w++)
 				{
 					// x/y Seamless!
-					uu = (u<0) ? (u + nx) : u; if (u>=nx) { uu-= nx; }
-					vv = (v<0) ? (v + ny) : v; if (v>=ny) { vv-= ny; }
+          uu = (u < 0) ? (u + nx) : u;
+          if (u >= nx) { uu -= nx; }
+          vv = (v < 0) ? (v + ny) : v;
+          if (v >= ny) { vv -= ny; }
 
 					clouds += c[uu][vv][w].cld ? 1 : 0;
 					div++;
@@ -565,12 +637,14 @@
 		return Ogre::Math::Clamp<float>(strength*((float)clouds)/div, 0, 1);
 	}
 
-	const float DataManager::_getDensityAt(Cell ***c, const int& x, const int& y, const int& z) const
+  float DataManager::_getDensityAt(Cell ***c, const int& x,
+      const int& y, const int& z) const
 	{
 		return c[x][y][z].cld ? 1.0f : 0.0f;
 	}
 
-	void DataManager::_createVolTexture(const VolTextureId& TexId, const int& nx, const int& ny, const int& nz)
+  void DataManager::_createVolTexture(const VolTextureId& TexId, const int& nx,
+      const int& ny, const int& nz)
 	{
 		mVolTextures[static_cast<int>(TexId)] 
 		    = Ogre::TextureManager::getSingleton().
@@ -584,17 +658,24 @@
 
 		static_cast<Ogre::MaterialPtr>(
 			Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds"))
-			->getTechnique(0)->getPass(0)->getTextureUnitState(static_cast<int>(TexId))
-				->setTextureName("_SkyX_VolCloudsData"+Ogre::StringConverter::toString(TexId), Ogre::TEX_TYPE_3D);
+      ->getTechnique(0)->getPass(0)->getTextureUnitState(
+          static_cast < int>(TexId))
+      ->setTextureName("_SkyX_VolCloudsData" +
+          Ogre::StringConverter::toString(TexId), Ogre::TEX_TYPE_3D);
 		static_cast<Ogre::MaterialPtr>(
-			Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds_Lightning"))
-			->getTechnique(0)->getPass(0)->getTextureUnitState(static_cast<int>(TexId))
-				->setTextureName("_SkyX_VolCloudsData"+Ogre::StringConverter::toString(TexId), Ogre::TEX_TYPE_3D);
+        Ogre::MaterialManager::getSingleton().getByName(
+          "SkyX_VolClouds_Lightning"))
+      ->getTechnique(0)->getPass(0)->getTextureUnitState(
+          static_cast < int>(TexId))
+      ->setTextureName("_SkyX_VolCloudsData" +
+          Ogre::StringConverter::toString(TexId), Ogre::TEX_TYPE_3D);
 	}
 
-	void DataManager::_updateVolTextureData(Cell ***c, const VolTextureId& TexId, const int& nx, const int& ny, const int& nz)
+  void DataManager::_updateVolTextureData(Cell ***c, const VolTextureId& TexId,
+      const int& /*nx*/, const int& /*ny*/, const int& /*nz*/)
 	{
-		Ogre::HardwarePixelBufferSharedPtr buffer = mVolTextures[TexId]->getBuffer(0,0);
+    Ogre::HardwarePixelBufferSharedPtr buffer =
+      mVolTextures[TexId]->getBuffer(0, 0);
 		
 		buffer->lock(Ogre::HardwareBuffer::HBL_DISCARD);
 		const Ogre::PixelBox &pb = buffer->getCurrentLock();
@@ -608,13 +689,14 @@
             {
                 for (x=pb.left; x<pb.right; x++)
 				{
-					Ogre::PixelUtil::packColour(c[x][y][z].dens/* TODO!!!! */, c[x][y][z].light, 0, 0, pb.format, &pbptr[x]);
+          Ogre::PixelUtil::packColour(c[x][y][z].dens/* TODO!!!! */,
+              c[x][y][z].light, 0, 0, pb.format, &pbptr[x]);
                 } 
                 pbptr += pb.rowPitch;
             }
             pbptr += pb.getSliceSkip();
         }
-
 		buffer->unlock();
 	}
-}}
\ No newline at end of file
+}
+}
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/Ellipsoid.cpp	2012-04-01 11:10:12.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/Ellipsoid.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -25,14 +25,15 @@
 
 namespace SkyX { namespace VClouds
 {
-
      Ellipsoid::Ellipsoid(
 		const int &a, const int &b, const int &c, 
 		const int &nx, const int &ny, const int &nz, 
 		const int &x, const int &y, const int &z,
 		const Ogre::Real& Density)
 		: mA(a), mB(b), mC(c)
-		, mA2(Ogre::Math::Pow(a, 2)), mB2(Ogre::Math::Pow(b, 2)), mC2(Ogre::Math::Pow(c, 2))
+      , mA2(Ogre::Math::Pow(a, 2))
+      , mB2(Ogre::Math::Pow(b, 2))
+      , mC2(Ogre::Math::Pow(c, 2))
 		, mNx(nx), mNy(ny), mNz(nz)
 		, mX(x), mY(y), mZ(z)
 		, mDensity(Density)
@@ -43,7 +44,7 @@
 	{
 	}
 
-	const float Ellipsoid::_getLength(const int &x, const int &y, const int &z) const
+  float Ellipsoid::_getLength(const int &x, const int &y, const int &z) const
 	{
 		if (x == mX && y == mY && z == mZ)
 		{
@@ -54,7 +55,9 @@
 		//  /   + /   + /    = 1  (Ellipsoid ecuation)
 		//  a^2   b^2   c^2
 		// 
-		//  maxradatdir = lambda (Xo, Yo, Zo) = lambda; where Xo, Yo and Zo are the components of the normaliced direction vector
+    //  maxradatdir = lambda (Xo, Yo, Zo) = lambda;
+    //  where Xo, Yo and Zo are the components of the
+    //  normaliced direction vector
 		//
 		//  => lambda^2 = 1 / ( EllipsoidEcuation...)
 		//
@@ -72,14 +75,17 @@
 		return Ogre::Math::Clamp<Ogre::Real>(Direction.length() / lambda, 0, 1);
 	}
 
-	const Ogre::Vector3 Ellipsoid::getProbabilities(const int& x, const int& y, const int& z) const
+  const Ogre::Vector3 Ellipsoid::getProbabilities(const int& x,
+      const int& y, const int& z) const
 	{
 		float density = Ogre::Math::Pow(1-_getLength(x, y, z), 1.0f/mDensity);
 
 		return Ogre::Vector3(density, 1-density, density);
 	}
 
-    void Ellipsoid::updateProbabilities(DataManager::Cell ***c, const int &nx, const int &ny, const int &nz, const bool& delayedResponse)
+  void Ellipsoid::updateProbabilities(DataManager::Cell ***c,
+      const int &nx, const int &ny, const int &/*nz*/,
+      const bool& delayedResponse)
 	{
 		int u, v, w, uu, vv;
 
@@ -87,11 +93,13 @@
 
 		for (u = mX-mA; u < mX+mA; u++)
 		{
-			uu = (u<0) ? (u + nx) : u; if (u>=nx) { uu-= nx; }
+      uu = (u < 0) ? (u + nx) : u;
+      if (u >= nx) { uu -= nx; }
 
 			for (v = mY-mB; v < mY+mB; v++)
 			{
-				vv = (v<0) ? (v + ny) : v; if (v>=ny) { vv-= ny; }
+        vv = (v < 0) ? (v + ny) : v;
+        if (v >= ny) { vv -= ny; }
 
 				for (w = mZ-mC; w < mZ+mC; w++)
 				{
@@ -105,7 +113,8 @@
 
 						if (!delayedResponse)
 						{
-							c[uu][vv][w].cld = Ogre::Math::RangeRandom(0,1) > length ? true : false;
+              c[uu][vv][w].cld = Ogre::Math::RangeRandom(0, 1) > length ?
+                true : false;
 						}
 					}
 				}
@@ -115,10 +124,12 @@
 
 	void Ellipsoid::move(const int& Ax, const int& Ay, const int& Az)
 	{
-		mX += Ax; mY += Ay; mZ += Az;
+    mX += Ax;
+    mY += Ay;
+    mZ += Az;
 	}
 
-	const bool Ellipsoid::isOutOfCells() const
+  bool Ellipsoid::isOutOfCells() const
 	{
 		if ( (mX+mA) >= mNx || (mX-mA) < 0 ||
 			 (mY+mB) >= mNy || (mY-mB) < 0 ||
@@ -140,5 +151,4 @@
 		mB2 = Ogre::Math::Pow(mB, 2); 
 		mC2 = Ogre::Math::Pow(mC, 2);
 	}
-
 }}
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/FastFakeRandom.cpp	2012-03-08 20:30:16.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/FastFakeRandom.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -25,7 +25,8 @@
 
 namespace SkyX { namespace VClouds
 {
-	FastFakeRandom::FastFakeRandom(const int &n, const Ogre::Real &min, const Ogre::Real &max)
+    FastFakeRandom::FastFakeRandom(const int &n, const Ogre::Real &min,
+        const Ogre::Real &max)
 		: mCapacity(n)
 		, mIndex(-1)
 	{
@@ -44,9 +45,12 @@
 
 	float& FastFakeRandom::get() 
 	{
-		mIndex ++; if (mIndex >= mCapacity) {mIndex = 0;}
+      mIndex++;
+      if (mIndex >= mCapacity)
+      {
+        mIndex = 0;
+      }
 
 		return mData[mIndex];
 	}
-
 }}
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/GeometryBlock.cpp	2013-02-23 23:29:16.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/GeometryBlock.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <algorithm>
 #include "VClouds/GeometryBlock.h"
 
 #include "VClouds/VClouds.h"
@@ -50,7 +51,6 @@
 		, mDisplacement(Ogre::Vector3(0,0,0))
 		, mWorldOffset(Ogre::Vector2(0,0))
 		, mCamera(0)
-		, mDistance(Ogre::Vector3(0,0,0))
 		, mLastFallingDistance(0)
 	{
 		_calculateDataSize();
@@ -66,7 +66,8 @@
 		remove();
 
 		// Create mesh and submesh
-		mMesh = Ogre::MeshManager::getSingleton().createManual("_SkyX_VClouds_Block" + Ogre::StringConverter::toString(mPosition),
+    mMesh = Ogre::MeshManager::getSingleton().createManual(
+        "_SkyX_VClouds_Block" + Ogre::StringConverter::toString(mPosition),
                     SKYX_RESOURCE_GROUP);
         mSubMesh = mMesh->createSubMesh();
         mSubMesh->useSharedVertices = false;
@@ -82,7 +83,9 @@
         mMesh->touch();
 
 		// Create entity
-        mEntity = mVClouds->getSceneManager()->createEntity("_SkyX_VClouds_BlockEnt" + Ogre::StringConverter::toString(mPosition), "_SkyX_VClouds_Block" + Ogre::StringConverter::toString(mPosition));
+    mEntity = mVClouds->getSceneManager()->createEntity(
+        "_SkyX_VClouds_BlockEnt" + Ogre::StringConverter::toString(mPosition),
+        "_SkyX_VClouds_Block" + Ogre::StringConverter::toString(mPosition));
         mEntity->setMaterialName("SkyX_VolClouds");
 		mEntity->setCastShadows(false);
 		mEntity->setRenderQueueGroup(mVClouds->getRenderQueueGroups().vclouds);
@@ -117,17 +120,25 @@
 	const Ogre::AxisAlignedBox GeometryBlock::_buildAABox(const float& fd) const
 	{
 		Ogre::Vector2 Center = Ogre::Vector2(0,0);
-		Ogre::Vector2 V1     = mRadius*Ogre::Vector2(Ogre::Math::Cos(mPhi*mPosition), Ogre::Math::Sin(mPhi*mPosition));
-		Ogre::Vector2 V2     = mRadius*Ogre::Vector2(Ogre::Math::Cos(mPhi*(mPosition+1)), Ogre::Math::Sin(mPhi*(mPosition+1)));
-
-		Ogre::Vector2 Max    = Ogre::Vector2(std::max<float>(std::max<float>(V1.x, V2.x), Center.x), std::max<float>(std::max<float>(V1.y, V2.y), Center.y) );
-		Ogre::Vector2 Min    = Ogre::Vector2(std::min<float>(std::min<float>(V1.x, V2.x), Center.x), std::min<float>(std::min<float>(V1.y, V2.y), Center.y) );
+    Ogre::Vector2 V1     = mRadius *
+      Ogre::Vector2(Ogre::Math::Cos(mPhi*mPosition),
+          Ogre::Math::Sin(mPhi*mPosition));
+    Ogre::Vector2 V2     = mRadius *
+      Ogre::Vector2(Ogre::Math::Cos(mPhi*(mPosition+1)),
+          Ogre::Math::Sin(mPhi*(mPosition+1)));
+
+    Ogre::Vector2 Max    = Ogre::Vector2(std::max<float>(
+          std::max<float>(V1.x, V2.x), Center.x),
+        std::max<float>(std::max<float>(V1.y, V2.y), Center.y) );
+    Ogre::Vector2 Min    = Ogre::Vector2(std::min<float>(
+          std::min<float>(V1.x, V2.x), Center.x),
+        std::min<float>(std::min<float>(V1.y, V2.y), Center.y) );
 
 		return Ogre::AxisAlignedBox(
 							  // Min x,y,z
-							  Min.x, -std::max<float>(fd,0),          Min.y,
+        Min.x, Min.y, -std::max<float>(fd, 0),
 							  // Max x,y,z
-			                  Max.x, mHeight - std::min<float>(fd,0), Max.y);
+        Max.x, Max.y, mHeight - std::min<float>(fd, 0));
 	}
 
 	void GeometryBlock::_calculateDataSize()
@@ -135,8 +146,10 @@
 		mVertexCount = 7*mNa + 6*mNb + 4*mNc;
 		mNumberOfTriangles = 5*mNa + 4*mNb + 2*mNc;
 
-		mV2Cos = Ogre::Vector2(Ogre::Math::Cos(mPosition*mPhi), Ogre::Math::Cos((mPosition+1)*mPhi));
-		mV2Sin = Ogre::Vector2(Ogre::Math::Sin(mPosition*mPhi), Ogre::Math::Sin((mPosition+1)*mPhi));
+    mV2Cos = Ogre::Vector2(Ogre::Math::Cos(mPosition*mPhi),
+        Ogre::Math::Cos((mPosition+1)*mPhi));
+    mV2Sin = Ogre::Vector2(Ogre::Math::Sin(mPosition*mPhi),
+        Ogre::Math::Sin((mPosition+1)*mPhi));
 
 		mBetaSin  = Ogre::Math::Sin(Ogre::Math::PI-mBeta.valueRadians());
 		mAlphaSin = Ogre::Math::Sin(Ogre::Math::PI-mAlpha.valueRadians());
@@ -150,20 +163,24 @@
 		mSubMesh->vertexData->vertexCount = mVertexCount;
 
 		Ogre::VertexDeclaration* vdecl = mSubMesh->vertexData->vertexDeclaration;
-		Ogre::VertexBufferBinding* vbind = mSubMesh->vertexData->vertexBufferBinding;
+    Ogre::VertexBufferBinding* vbind =
+      mSubMesh->vertexData->vertexBufferBinding;
 
 		size_t offset = 0;
 		// Position
 		vdecl->addElement(0, offset, Ogre::VET_FLOAT3, Ogre::VES_POSITION);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT3);
 		// 3D coords
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT3, Ogre::VES_TEXTURE_COORDINATES, 0);
+    vdecl->addElement(0, offset, Ogre::VET_FLOAT3,
+        Ogre::VES_TEXTURE_COORDINATES, 0);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT3);
 		// Noise coords
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 1);
+    vdecl->addElement(0, offset, Ogre::VET_FLOAT2,
+        Ogre::VES_TEXTURE_COORDINATES, 1);
 		offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT2);
 		// Opacity
-		vdecl->addElement(0, offset, Ogre::VET_FLOAT1, Ogre::VES_TEXTURE_COORDINATES, 2);
+    vdecl->addElement(0, offset, Ogre::VET_FLOAT1,
+        Ogre::VES_TEXTURE_COORDINATES, 2);
 
 		mVertexBuffer = Ogre::HardwareBufferManager::getSingleton().
 			createVertexBuffer(sizeof(VERTEX),
@@ -172,7 +189,7 @@
 
 		vbind->setBinding(0, mVertexBuffer);
 
-		unsigned short *indexbuffer = new unsigned short[mNumberOfTriangles*3];
+    uint16_t *indexbuffer = new uint16_t[mNumberOfTriangles*3];
 
 		int IndexOffset = 0;
 		int VertexOffset = 0;
@@ -277,7 +294,8 @@
 		mVertices = new VERTEX[mVertexCount];
 	}
 
-	void GeometryBlock::updateGeometry(Ogre::Camera* c, const Ogre::Vector3& displacement, const Ogre::Vector3& distance)
+  void GeometryBlock::updateGeometry(Ogre::Camera* c,
+                                     const Ogre::Vector3& displacement)
 	{
 		if (!mCreated)
 		{
@@ -286,7 +304,9 @@
 
 		mDisplacement = displacement;
 
-		float fallingDistance = mVClouds->getDistanceFallingParams().x*(mEntity->getParentSceneNode()->_getDerivedPosition().y-c->getDerivedPosition().y);
+    float fallingDistance = mVClouds->getDistanceFallingParams().x*
+      (mEntity->getParentSceneNode()->_getDerivedPosition().z-
+       c->getDerivedPosition().z);
 
 		if (mVClouds->getDistanceFallingParams().y > 0) // -1 means no max falling
 		{
@@ -306,7 +326,7 @@
 			}
 		}
 
-		if (fallingDistance != mLastFallingDistance)
+    if (!equal(fallingDistance, mLastFallingDistance))
 		{
 			mLastFallingDistance = fallingDistance;
 			mMesh->_setBounds(_buildAABox(mLastFallingDistance));
@@ -315,7 +335,6 @@
 		if (isInFrustum(c))
 		{
 			mCamera = c;
-			mDistance = distance;
 			_updateGeometry();
 		}
 	}
@@ -352,7 +371,7 @@
 	{
 		int VertexOffset = n*4;
 
-		// TODO, calculate constants by zone, not by slice
+    // TODO calculate constants by zone, not by slice
 		float Radius = mB+((mC-mB)/mNc)*(mNc-n);
 
 		Radius += mDisplacement.z;
@@ -386,9 +405,11 @@
 		// Vertex 1
 		_setVertexData(VertexOffset+1, or1, opacity);
 		// Vertex 2
-		_setVertexData(VertexOffset+2, or0+(Ogre::Vector3(x2.x, y0, z2.x)-or0).normalisedCopy()*hip, opacity);
+    _setVertexData(VertexOffset+2, or0+
+        (Ogre::Vector3(x2.x, y0, z2.x)-or0).normalisedCopy()*hip, opacity);
 		// Vertex 3
-		_setVertexData(VertexOffset+3, or1+(Ogre::Vector3(x2.y, y0, z2.y)-or1).normalisedCopy()*hip, opacity);
+    _setVertexData(VertexOffset+3,
+        or1+(Ogre::Vector3(x2.y, y0, z2.y)-or1).normalisedCopy()*hip, opacity);
 	}
 
 	void GeometryBlock::_updateZoneBSlice(const int& n)
@@ -440,9 +461,11 @@
 			 hip = (mHeight-y0) / Ogre::Math::Sin(ang);
 
 		// Vertex 4
-		_setVertexData(VertexOffset+4, or0 + (Ogre::Vector3(x3.x, y1, z3.x)-or0).normalisedCopy()*hip, opacity);
+    _setVertexData(VertexOffset+4, or0 +
+        (Ogre::Vector3(x3.x, y1, z3.x)-or0).normalisedCopy()*hip, opacity);
 		// Vertex 5
-		_setVertexData(VertexOffset+5, or1 + (Ogre::Vector3(x3.y, y1, z3.y)-or1).normalisedCopy()*hip, opacity);
+    _setVertexData(VertexOffset+5, or1 +
+        (Ogre::Vector3(x3.y, y1, z3.y)-or1).normalisedCopy()*hip, opacity);
 	}
 
 	void GeometryBlock::_updateZoneASlice(const int& n)
@@ -486,10 +509,13 @@
 		_setVertexData(VertexOffset+6, Ogre::Vector3(0, Radius, 0), opacity);
 	}
 
-	void GeometryBlock::_setVertexData(const int& index, const Ogre::Vector3& p, const float& o)
+  void GeometryBlock::_setVertexData(const int& index, const Ogre::Vector3& p,
+      const float& o)
 	{
-		float yDist = -mDistance.y;
-		float fallingDistance = mVClouds->getDistanceFallingParams().x*yDist*(Ogre::Vector2(p.x,p.z).length()/mRadius);
+    float fallingDistance = mVClouds->getDistanceFallingParams().x*
+      (mEntity->getParentSceneNode()->_getDerivedPosition().z-
+       mCamera->getDerivedPosition().z)*
+      (Ogre::Vector2(p.x, p.z).length()/mRadius);
 		
 		if (mVClouds->getDistanceFallingParams().y > 0) // -1 means no max falling
 		{
@@ -509,49 +535,40 @@
 			}
 		}
 
-		fallingDistance *= Ogre::Math::Sign(yDist);
-		
 		// Position
 		mVertices[index].x = p.x;
-		if (yDist < -mHeight/2)
-		{
-			// Over-cloud
-			mVertices[index].y = mHeight - p.y;
-		}
-		else // Under-cloud
-		{
-			mVertices[index].y = p.y - fallingDistance;
-		}
-		mVertices[index].z = p.z;
+    // Z-Up
+    mVertices[index].y = p.z;
+    mVertices[index].z = p.y - fallingDistance;
 
 		// 3D coords (Z-UP)
 		float scale = mVClouds->getCloudFieldScale()/mRadius;
 		mVertices[index].xc = (p.x+mWorldOffset.x)*scale;
 		mVertices[index].yc = (p.z+mWorldOffset.y)*scale;
 		mVertices[index].zc = Ogre::Math::Clamp<Ogre::Real>(p.y/mHeight, 0, 1);
-		if (yDist < -mHeight/2)
-		{
-			// Over-cloud
-			mVertices[index].zc = 1.0f - mVertices[index].zc;
-		}
 
 		// Noise coords
 		float noise_scale = mVClouds->getNoiseScale()/mRadius;
 		float xz_length_radius = Ogre::Vector2(p.x,p.z).length() / mRadius;
-		Ogre::Vector3 origin = Ogre::Vector3(0,-(mEntity->getParentSceneNode()->_getDerivedPosition().y-mCamera->getDerivedPosition().y) -mRadius*(0.5f+0.5f*Ogre::Vector2(p.x,p.z).length()/mRadius),0);
+    Ogre::Vector3 origin = Ogre::Vector3(0,
+        -(mEntity->getParentSceneNode()->_getDerivedPosition().y-
+          mCamera->getDerivedPosition().y) -mRadius*(0.5f+0.5f*
+          Ogre::Vector2(p.x, p.z).length()/mRadius), 0);
+
 		Ogre::Vector3 dir = (p-origin).normalisedCopy();
-		float hip = Ogre::Math::Sqrt(Ogre::Math::Pow(xz_length_radius * mRadius, 2) + Ogre::Math::Pow(origin.y, 2));
+    float hip = Ogre::Math::Sqrt(
+        Ogre::Math::Pow(xz_length_radius * mRadius, 2) +
+        Ogre::Math::Pow(origin.y, 2));
+
 		Ogre::Vector3 uv = dir*hip; // Only x/z, += origin doesn't need
 		mVertices[index].u = (uv.x+mWorldOffset.x)*noise_scale;
 		mVertices[index].v = (uv.z+mWorldOffset.y)*noise_scale;
 
 		// Opacity
-		float dist = (mDistance - Ogre::Vector3(p.x, p.y - fallingDistance, p.z)).length();
-		float att = Ogre::Math::Clamp((dist-mA/3.25f)/(mA/3.25f),0.0f,1.0f);
-		mVertices[index].o = o * att * mVClouds->getGlobalOpacity();
+    mVertices[index].o = o * mVClouds->getGlobalOpacity();
 	}
 
-	const bool GeometryBlock::isInFrustum(Ogre::Camera *c) const
+  bool GeometryBlock::isInFrustum(Ogre::Camera *c) const
 	{
 		if (!mCreated)
 		{
@@ -559,7 +576,8 @@
 		}
 
 		// TODO: Use a world bounding box for each geometry zone, this way the
-		// culling is going to be more acurrated and the geometry falling is going to be culled
+    // culling is going to be more acurrated and the geometry falling is going
+    // to be culled
 		// when the falling factor is bigger than 1.
 		return c->isVisible(mEntity->getParentSceneNode()->_getWorldAABB());
 	}
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/GeometryManager.cpp	2012-12-27 00:37:36.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/GeometryManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,13 +21,13 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "VClouds/GeometryManager.h"
 
 #include "VClouds/VClouds.h"
 
 namespace SkyX { namespace VClouds
 {
-
 	GeometryManager::GeometryManager(VClouds* vc)
 		: mVClouds(vc)
 		, mCreated(false)
@@ -40,7 +40,6 @@
 		, mNa(0), mNb(0), mNc(0)
 		, mA(0), mB(0), mC(0)
 		, mWorldOffset(Ogre::Vector2(0,0))
-		, mCurrentDistance(Ogre::Vector3(0,0,0))
 	{
 	}
 
@@ -49,9 +48,11 @@
 		remove();
 	}
 
-	void GeometryManager::create(const Ogre::Vector2& Height, const float& Radius,
+    void GeometryManager::create(const Ogre::Vector2& Height,
+            const float& Radius,
 		    const Ogre::Radian& Alpha, const Ogre::Radian& Beta, 
-            const int& NumberOfBlocks, const int& Na, const int& Nb, const int& Nc)
+            const int& NumberOfBlocks, const int& Na, const int& Nb,
+            const int& Nc)
 	{
 		remove();
 
@@ -61,9 +62,12 @@
 		mBeta = Beta;
 		mPhi = Ogre::Math::TWO_PI / NumberOfBlocks;
 		mNumberOfBlocks = NumberOfBlocks;
-		mNa = Na; mNb = Nb; mNc = Nc;
+        mNa = Na;
+        mNb = Nb;
+        mNc = Nc;
 
-		mSceneNode = mVClouds->getSceneManager()->getRootSceneNode()->createChildSceneNode();
+        mSceneNode = mVClouds->getSceneManager()->getRootSceneNode()->
+          createChildSceneNode();
 		_createGeometry();
 
 		mCreated = true;
@@ -77,7 +81,8 @@
 		}
 
 		mSceneNode->detachAllObjects();
-		mSceneNode->getParentSceneNode()->removeAndDestroyChild(mSceneNode->getName());
+        mSceneNode->getParentSceneNode()->removeAndDestroyChild(
+            mSceneNode->getName());
 		mSceneNode = 0;
 
 		for (int k = 0; k < mNumberOfBlocks; k++)
@@ -98,17 +103,20 @@
 			return;
 		}
 
-		mWorldOffset += mVClouds->getWindDirectionV2() * mVClouds->getWindSpeed() * timeSinceLastFrame;
+        mWorldOffset += mVClouds->getWindDirectionV2() *
+          mVClouds->getWindSpeed() * timeSinceLastFrame;
 	}
 
-	void GeometryManager::updateGeometry(Ogre::Camera* c, const Ogre::Real& timeSinceLastCameraFrame)
+    void GeometryManager::updateGeometry(Ogre::Camera* c,
+        const Ogre::Real& timeSinceLastCameraFrame)
 	{
 		if (!mCreated)
 		{
 			return;
 		}
 
-		mSceneNode->setPosition(mVClouds->getCamera()->getDerivedPosition().x, mHeight.x, mVClouds->getCamera()->getDerivedPosition().z);
+        mSceneNode->setPosition(mVClouds->getCamera()->getDerivedPosition().x,
+            mVClouds->getCamera()->getDerivedPosition().y, mHeight.x);
 		mSceneNode->_update(false, false);
 
 		_updateGeometry(c, timeSinceLastCameraFrame);
@@ -132,27 +140,35 @@
 
 	void GeometryManager::_createGeometry()
 	{
-		mA = mHeight.y / Ogre::Math::Cos(Ogre::Math::PI/2-mBeta.valueRadians());
-		mB = mHeight.y / Ogre::Math::Cos(Ogre::Math::PI/2-mAlpha.valueRadians());
+        mA = mHeight.y /
+          Ogre::Math::Cos(Ogre::Math::PI/2-mBeta.valueRadians());
+        mB = mHeight.y /
+          Ogre::Math::Cos(Ogre::Math::PI/2-mAlpha.valueRadians());
 	    mC = mRadius;
 
 		for (int k = 0; k < mNumberOfBlocks; k++)
 		{
-			mGeometryBlocks.push_back(new GeometryBlock(mVClouds, mHeight.y, mAlpha, mBeta, mRadius, mPhi, mNa, mNb, mNc, mA, mB, mC, k));
+            mGeometryBlocks.push_back(new GeometryBlock(mVClouds,
+                  mHeight.y, mAlpha, mBeta, mRadius, mPhi, mNa, mNb, mNc,
+                  mA, mB, mC, k));
 			mGeometryBlocks.at(k)->create();
-			// Each geometry block must be in a different scene node, See: GeometryBlock::isInFrustum(Ogre::Camera *c)
+            // Each geometry block must be in a different scene node,
+            // See: GeometryBlock::isInFrustum(Ogre::Camera *c)
 			Ogre::SceneNode *sn = mSceneNode->createChildSceneNode();
 			sn->attachObject(mGeometryBlocks.at(k)->getEntity());
 		}
 	}
 
-	void GeometryManager::_updateGeometry(Ogre::Camera* c, const Ogre::Real& timeSinceLastFrame)
+    void GeometryManager::_updateGeometry(Ogre::Camera* c,
+        const Ogre::Real& timeSinceLastFrame)
 	{
 		// Look for current camera data
-		std::vector<VClouds::CameraData>& camerasData = mVClouds->_getCamerasData();
+        std::vector<VClouds::CameraData>& camerasData =
+          mVClouds->_getCamerasData();
 		std::vector<VClouds::CameraData>::iterator currentCameraDataIt;
 
-		for (currentCameraDataIt = camerasData.begin(); currentCameraDataIt != camerasData.end(); currentCameraDataIt++)
+        for (currentCameraDataIt = camerasData.begin();
+            currentCameraDataIt != camerasData.end(); currentCameraDataIt++)
 		{
 			if ((*currentCameraDataIt).camera == c)
 			{
@@ -160,14 +176,20 @@
 			}
 		}
 
-		std::vector<VClouds::CameraData>::reference currentCameraData = (*currentCameraDataIt);
+        std::vector<VClouds::CameraData>::reference currentCameraData =
+          (*currentCameraDataIt);
 
 		// Calculate wind offset
-		Ogre::Vector2 CameraDirection = Ogre::Vector2(c->getDerivedDirection().x, c->getDerivedDirection().z);
-		float offset = - CameraDirection.dotProduct(mVClouds->getWindDirectionV2()) * mVClouds->getWindSpeed() * timeSinceLastFrame;
+        Ogre::Vector2 CameraDirection =
+          Ogre::Vector2(c->getDerivedDirection().x, c->getDerivedDirection().y);
+        float offset = -CameraDirection.dotProduct(
+            mVClouds->getWindDirectionV2()) * mVClouds->getWindSpeed() *
+          timeSinceLastFrame;
 
 		// Calculate camera offset
-		Ogre::Vector2 CameraOffset = Ogre::Vector2(c->getDerivedPosition().x - currentCameraData.lastPosition.x, c->getDerivedPosition().z - currentCameraData.lastPosition.z);
+        Ogre::Vector2 CameraOffset = Ogre::Vector2(
+            c->getDerivedPosition().x - currentCameraData.lastPosition.x,
+            c->getDerivedPosition().y - currentCameraData.lastPosition.y);
 		offset -= CameraOffset.dotProduct(CameraDirection);
 
 		// Update camera data
@@ -177,28 +199,36 @@
 		// Update geometry displacement
 		currentCameraData.geometryDisplacement += Ogre::Vector3(offset);
 
-		if (currentCameraData.geometryDisplacement.z < 0 || currentCameraData.geometryDisplacement.z > (mC-mB)/mNc)
+        if (currentCameraData.geometryDisplacement.z < 0 ||
+            currentCameraData.geometryDisplacement.z > (mC-mB)/mNc)
 		{
-			currentCameraData.geometryDisplacement.z -= ((mC-mB)/mNc)*Ogre::Math::IFloor((currentCameraData.geometryDisplacement.z)/((mC-mB)/mNc));
+            currentCameraData.geometryDisplacement.z -=
+              ((mC-mB)/mNc)*Ogre::Math::IFloor(
+                (currentCameraData.geometryDisplacement.z)/((mC-mB)/mNc));
 		}
 
-		if (currentCameraData.geometryDisplacement.y < 0 || currentCameraData.geometryDisplacement.y > (mB-mA)/mNb)
+        if (currentCameraData.geometryDisplacement.y < 0 ||
+            currentCameraData.geometryDisplacement.y > (mB-mA)/mNb)
 		{
-			currentCameraData.geometryDisplacement.y -= ((mB-mA)/mNb)*Ogre::Math::IFloor((currentCameraData.geometryDisplacement.y)/((mB-mA)/mNb));
+            currentCameraData.geometryDisplacement.y -=
+              ((mB-mA)/mNb)*Ogre::Math::IFloor(
+                (currentCameraData.geometryDisplacement.y)/((mB-mA)/mNb));
 		}
 
-		if (currentCameraData.geometryDisplacement.x < 0 || currentCameraData.geometryDisplacement.x > mA/mNa)
+        if (currentCameraData.geometryDisplacement.x < 0 ||
+            currentCameraData.geometryDisplacement.x > mA/mNa)
 		{
-			currentCameraData.geometryDisplacement.x -= (mA/mNa)*Ogre::Math::IFloor((currentCameraData.geometryDisplacement.x)/(mA/mNa));
+            currentCameraData.geometryDisplacement.x -=
+              (mA/mNa)*Ogre::Math::IFloor(
+                  (currentCameraData.geometryDisplacement.x)/(mA/mNa));
 		}
 
-		// Check under/over cloud rendering
-		mCurrentDistance = c->getDerivedPosition()-mSceneNode->_getDerivedPosition();
-
 		for (int k = 0; k < mNumberOfBlocks; k++)
 		{
-			mGeometryBlocks.at(k)->setWorldOffset(mWorldOffset + currentCameraData.cameraOffset);
-			mGeometryBlocks.at(k)->updateGeometry(c, currentCameraData.geometryDisplacement, mCurrentDistance);
+            mGeometryBlocks.at(k)->setWorldOffset(
+                mWorldOffset + currentCameraData.cameraOffset);
+            mGeometryBlocks.at(k)->updateGeometry(c,
+                currentCameraData.geometryDisplacement);
 		}
 	}
 }}
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/Lightning.cpp	2012-04-01 10:19:46.000000000 -0400
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/Lightning.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,12 +21,15 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "VClouds/Lightning.h"
 
 namespace SkyX { namespace VClouds
 {
-	Lightning::Lightning(Ogre::SceneManager* sm, Ogre::SceneNode* sn, const Ogre::Vector3& orig, const Ogre::Vector3& dir, 
-		const Ogre::Real& l, const Ogre::uint32& d, const Ogre::uint32& rec, const Ogre::Real& tm, const Ogre::Real& wm, const Ogre::Vector2& b)
+  Lightning::Lightning(Ogre::SceneManager* sm, Ogre::SceneNode* sn,
+      const Ogre::Vector3& orig, const Ogre::Vector3& dir,
+      const Ogre::Real& l, const Ogre::uint32& d, const Ogre::uint32& rec,
+      const Ogre::Real& tm, const Ogre::Real& wm, const Ogre::Vector2& b)
 		: mOrigin(orig)
 		, mDirection(dir)
 		, mLength(l)
@@ -38,8 +41,11 @@
 		, mIntensity(0)
 		, mWidthMultiplier(wm)
 		, mBounds(b)
-		, mAngleRange(Ogre::Vector2(Ogre::Math::RangeRandom(0.3,0.5), Ogre::Math::RangeRandom(0.6,0.8)))
-		, mTimeMultipliers(Ogre::Vector3(Ogre::Math::RangeRandom(1.75,4.25), Ogre::Math::RangeRandom(0.4,1.25f), Ogre::Math::RangeRandom(0.2,1.0f)))
+      , mAngleRange(Ogre::Vector2(Ogre::Math::RangeRandom(0.3, 0.5),
+            Ogre::Math::RangeRandom(0.6, 0.8)))
+      , mTimeMultipliers(Ogre::Vector3(Ogre::Math::RangeRandom(1.75, 4.25),
+            Ogre::Math::RangeRandom(0.4, 1.25f),
+            Ogre::Math::RangeRandom(0.2, 1.0f)))
 		, mSegments(std::vector<Lightning::Segment>())
 		, mChildren(std::vector<Lightning*>())
 		, mBillboardSet(0)
@@ -59,22 +65,24 @@
 	{
 		remove();
 
-		Ogre::Vector3 end = mOrigin + mDirection*mLength;
+    // Ogre::Vector3 end = mOrigin + mDirection*mLength;
 		Ogre::Vector3 current, last = mOrigin;
 
 		// Create ray segments
 		for(Ogre::uint32 k = 1; k < mDivisions+1; k++)
 		{
-			Ogre::Vector3 current = mOrigin + mDirection*mLength*(static_cast<Ogre::Real>(k)/mDivisions);
+      Ogre::Vector3 curr = mOrigin +
+        mDirection*mLength*(static_cast<Ogre::Real>(k)/mDivisions);
 
-			current += (mLength/(mDivisions*3))*Ogre::Vector3(
-				Ogre::Math::RangeRandom(-1, 1), Ogre::Math::RangeRandom(-1, 1), Ogre::Math::RangeRandom(-1, 1));
+      curr += (mLength/(mDivisions*3))*Ogre::Vector3(
+          Ogre::Math::RangeRandom(-1, 1), Ogre::Math::RangeRandom(-1, 1),
+          Ogre::Math::RangeRandom(-1, 1));
 
-			mSegments.push_back(Segment(last, current));
+      mSegments.push_back(Segment(last, curr));
 
-			mRealLength += (current-last).length();
+      mRealLength += (curr - last).length();
 
-			last = current;
+      last = curr;
 		}
 
 		// Create the associated billboard set
@@ -82,7 +90,8 @@
 		mBillboardSet->setMaterialName("SkyX_Lightning");
 		mBillboardSet->setBillboardType(Ogre::BBT_ORIENTED_SELF);
 
-		Ogre::Real width = mWidthMultiplier*3*(static_cast<Ogre::Real>(mRecursivity)/4+1)*Ogre::Math::RangeRandom(0.5f, 2.5f-mRecursivity/3);
+    Ogre::Real width = mWidthMultiplier*3*(static_cast<Ogre::Real>(
+          mRecursivity)/4+1)*Ogre::Math::RangeRandom(0.5f, 2.5f-mRecursivity/3);
 
 		// Create the associated billboard for each segment
 		Ogre::Real delta;
@@ -93,24 +102,30 @@
 			delta = 1.0f / mSegments.size();
 			bounds = Ogre::Vector2(k*delta,(k+1)*delta);
 
-			bounds = Ogre::Vector2(mBounds.x, mBounds.x) + bounds*(mBounds.y-mBounds.x);
+      bounds = Ogre::Vector2(mBounds.x, mBounds.x) +
+        bounds*(mBounds.y-mBounds.x);
 
-			bb = mBillboardSet->createBillboard((mSegments.at(k).a+mSegments.at(k).b)/2);
+      bb = mBillboardSet->createBillboard((
+            mSegments.at(k).a+mSegments.at(k).b)/2);
 			bb->setDimensions(width, (mSegments.at(k).a-mSegments.at(k).b).length());
 			bb->setColour(Ogre::ColourValue(0,bounds.x,bounds.y));
 			bb->mDirection = (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy();
 
-			bb = mBillboardSet->createBillboard(mSegments.at(k).a + (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy()*width/2);
+      bb = mBillboardSet->createBillboard(
+          mSegments.at(k).a +
+          (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy()*width/2);
 			bb->setDimensions(width, width);
 			bb->setColour(Ogre::ColourValue(1,bounds.x,bounds.x));
 			bb->mDirection = (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy();
 			
-			bb = mBillboardSet->createBillboard(mSegments.at(k).b - (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy()*width/2);
+      bb = mBillboardSet->createBillboard(mSegments.at(k).b -
+          (mSegments.at(k).a-mSegments.at(k).b).normalisedCopy()*width/2);
 			bb->setDimensions(width, width);
 			bb->setColour(Ogre::ColourValue(1,bounds.y,bounds.y));
 			bb->mDirection = -(mSegments.at(k).a-mSegments.at(k).b).normalisedCopy();
 		
-			width *= 1-(1.0f/(mRecursivity*mRecursivity+1.0f))*(1.0f/mSegments.size());
+      width *= 1-(1.0f/(mRecursivity*mRecursivity+1.0f))*
+        (1.0f/mSegments.size());
 		}
 
 		mBillboardSet->_updateBounds();
@@ -127,7 +142,8 @@
 			Ogre::Real lengthMult;
 			for (Ogre::uint32 k = 0; k < mDivisions-1; k++)
 			{
-				angle = (mSegments.at(k).b-mSegments.at(k).a).normalisedCopy().dotProduct(
+        angle = (mSegments.at(k).b-mSegments.at(k).a).
+          normalisedCopy().dotProduct(
 					((mSegments.at(k+1).b-mSegments.at(k+1).a).normalisedCopy()));
 
 				if (angle < Ogre::Math::RangeRandom(mAngleRange.x, mAngleRange.y))
@@ -139,11 +155,15 @@
 					dir.normalise();
 
 					delta = 1.0f / mSegments.size();
-					bounds = Ogre::Vector2(mBounds.x+(mBounds.y-mBounds.x)*(k+1)*delta,1);
+          bounds = Ogre::Vector2(mBounds.x+
+              (mBounds.y-mBounds.x)*(k+1)*delta, 1);
 
 					lengthMult = Ogre::Math::RangeRandom(0.1f, 0.7f);
 
-					Lightning* lightning = new Lightning(mSceneManager, mSceneNode, mSegments.at(k).b, dir, lengthMult*mLength, 2+mDivisions*lengthMult, mRecursivity-1, mTimeMultiplier, mWidthMultiplier, bounds);
+          Lightning* lightning = new Lightning(mSceneManager,
+              mSceneNode, mSegments.at(k).b, dir, lengthMult*mLength,
+              2+mDivisions*lengthMult, mRecursivity-1, mTimeMultiplier,
+              mWidthMultiplier, bounds);
 					lightning->create();
 					
 					mChildren.push_back(lightning);
@@ -218,7 +238,8 @@
 			}
 			else // Sinus flashing pattern
 			{
-				alpha += Ogre::Math::Abs(Ogre::Math::Sin((mTime-1.2f)*1.5f*mTimeMultipliers.x));
+        alpha += Ogre::Math::Abs(Ogre::Math::Sin((mTime-1.2f)*
+              1.5f*mTimeMultipliers.x));
 			}
 		}
 		else if (mTime > 2) // Ray fading
@@ -231,7 +252,8 @@
 				 mFinished = true;
 			 }
 
-			alpha += Ogre::Math::Abs(Ogre::Math::Sin((2-1.2f)*1.5f*mTimeMultipliers.x));
+      alpha += Ogre::Math::Abs(
+          Ogre::Math::Sin((2-1.2f)*1.5f*mTimeMultipliers.x));
 			alpha *= 3.0f-mTime;
 		}
 
@@ -250,9 +272,11 @@
 		}
 	}
 
-	void Lightning::_updateData(const Ogre::Real& alpha, const Ogre::Real& currentPos, const Ogre::Real& parentTime)
+  void Lightning::_updateData(const Ogre::Real& alpha,
+      const Ogre::Real& currentPos, const Ogre::Real& parentTime)
 	{
-		Ogre::Vector4 params = Ogre::Vector4(alpha,currentPos,(3-mRecursivity)*0.075f+(mBounds.x*1.5f+0.2f)*0.85f,0);
+    Ogre::Vector4 params = Ogre::Vector4(alpha, currentPos,
+        (3-mRecursivity)*0.075f+(mBounds.x*1.5f+0.2f)*0.85f, 0);
 
 		if (parentTime > 1 && parentTime < 2.2f)
 		{
@@ -260,7 +284,8 @@
 		}
 		else if (parentTime > 2.2f)
 		{
-			 params.z *= Ogre::Math::Clamp<Ogre::Real>((-2.2f+parentTime)*1.25f,0.2f,1);
+      params.z *= Ogre::Math::Clamp<Ogre::Real>(
+          (-2.2f+parentTime)*1.25f, 0.2f, 1);
 		}
 
 		mBillboardSet->setCustomParameter(0, params);
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/LightningManager.cpp	2012-12-27 01:39:48.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/LightningManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,13 +21,13 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "VClouds/LightningManager.h"
 
 #include "VClouds/VClouds.h"
 
 namespace SkyX { namespace VClouds
 {
-
 	LightningManager::LightningManager(VClouds* vc)
 		: mVClouds(vc)
 		, mLightnings(std::vector<Lightning*>())
@@ -53,18 +53,23 @@
 	{
 		remove();
 
-		mVolCloudsLightningMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds_Lightning"));
-		mLightningMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("SkyX_Lightning"));
+    mVolCloudsLightningMaterial = static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName(
+          "SkyX_VolClouds_Lightning"));
+    mLightningMaterial = static_cast<Ogre::MaterialPtr>(
+        Ogre::MaterialManager::getSingleton().getByName("SkyX_Lightning"));
 
 		if (mLightningMaterial.isNull())
 		{
-			SkyXLOG("Error while creating SkyX::VClouds::LightningManager, material not found");
+      SkyXLOG("Error while creating SkyX::VClouds::LightningManager,  "
+              "material not found");
 			return;
 		}
 
 		if (mEnabled)
 		{
-			mVClouds->getGeometryManager()->_setMaterialName("SkyX_VolClouds_Lightning");
+      mVClouds->getGeometryManager()->_setMaterialName(
+          "SkyX_VolClouds_Lightning");
 		}
 		else
 		{
@@ -114,12 +119,14 @@
 
 			if (mRemainingTime <= 0)
 			{
-				mRemainingTime = Ogre::Math::RangeRandom(0, 2*mAverageLightningApparitionTime);
+        mRemainingTime = Ogre::Math::RangeRandom(0,
+            2*mAverageLightningApparitionTime);
 
 				// Select a random camera to place the lightning
 				if (!mVClouds->_getCamerasData().empty())
 				{
-					Ogre::Camera* c = mVClouds->_getCamerasData().at(mVClouds->_getCamerasData().size()*0.999).camera;
+          Ogre::Camera* c = mVClouds->_getCamerasData().at(
+              mVClouds->_getCamerasData().size()*0.999).camera;
 
 					Ogre::Real prob = Ogre::Math::RangeRandom(0,1);
 					
@@ -128,41 +135,77 @@
 					{
 						addLightning(
 							// Ray position
-							Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5)), 
+                Ogre::Vector3(c->getDerivedPosition().x +
+                  Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,
+                    c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1, 5),
+                  c->getDerivedPosition().y + Ogre::Math::RangeRandom(
+                    -c->getFarClipDistance()*0.5, c->getFarClipDistance()*0.5)/
+                  Ogre::Math::RangeRandom(1, 5),
+                  mVClouds->getGeometrySettings().Height.x +
+                  0.2*mVClouds->getGeometrySettings().Height.y),
 							// Ray direction
-							Ogre::Vector3(0,-1,0), 
+                Ogre::Vector3(0,  0, -1),
 							// Ray length
-							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);
+                mVClouds->getGeometrySettings().Height.x +
+                0.1*mVClouds->getGeometrySettings().Height.y);
 					}
 					// Cloud-to-cloud
 					else if (prob < 0.7)
 					{
 						addLightning(
 							// Ray position
-							Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5)), 
+                Ogre::Vector3(c->getDerivedPosition().x +
+                  Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,
+                    c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1, 5),
+                  c->getDerivedPosition().y + Ogre::Math::RangeRandom(
+                    -c->getFarClipDistance()*0.5, c->getFarClipDistance()*0.5)/
+                  Ogre::Math::RangeRandom(1, 5),
+                  mVClouds->getGeometrySettings().Height.x + 0.2*
+                  mVClouds->getGeometrySettings().Height.y),
 							// Ray direction
-							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
+                Ogre::Vector3(Ogre::Math::RangeRandom(-1,  1),
+                  Ogre::Math::RangeRandom(-1,  1),
+                  Ogre::Math::RangeRandom(-0.1,  0.1)).normalisedCopy(),
 							// Ray length
-							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
+                Ogre::Math::RangeRandom(0.5,  1.5f)*0.2*
+                mVClouds->getGeometrySettings().Height.y);
 					}
 					// Cloud-to-ground + cloud-to-cloud
 					else
 					{
 						addLightning(
 							// Ray position
-							Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5)), 
+                Ogre::Vector3(c->getDerivedPosition().x +
+                  Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,
+                    c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1, 5),
+                  c->getDerivedPosition().y + Ogre::Math::RangeRandom(
+                    -c->getFarClipDistance()*0.5, c->getFarClipDistance()*0.5)/
+                  Ogre::Math::RangeRandom(1,  5),
+                  mVClouds->getGeometrySettings().Height.x +
+                  0.2*mVClouds->getGeometrySettings().Height.y),
 							// Ray direction
-							Ogre::Vector3(0,-1,0), 
+                Ogre::Vector3(0,  0,  -1),
 							// Ray length
-							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);
+                mVClouds->getGeometrySettings().Height.x +
+                0.1*mVClouds->getGeometrySettings().Height.y);
 
 						addLightning(
 							// Ray position
-							Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,5)), 
+                Ogre::Vector3(c->getDerivedPosition().x +
+                  Ogre::Math::RangeRandom(-c->getFarClipDistance()*0.5,
+                    c->getFarClipDistance()*0.5)/Ogre::Math::RangeRandom(1,  5),
+                  c->getDerivedPosition().y + Ogre::Math::RangeRandom(
+                    -c->getFarClipDistance()*0.5,  c->getFarClipDistance()*0.5)/
+                  Ogre::Math::RangeRandom(1,  5),
+                  mVClouds->getGeometrySettings().Height.x +
+                  0.2*mVClouds->getGeometrySettings().Height.y),
 							// Ray direction
-							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
+                Ogre::Vector3(Ogre::Math::RangeRandom(-1,  1),
+                  Ogre::Math::RangeRandom(-1,  1),
+                  Ogre::Math::RangeRandom(-0.1,  0.1)).normalisedCopy(),
 							// Ray length
-							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
+                Ogre::Math::RangeRandom(0.5,  1.5f)*0.2*
+                mVClouds->getGeometrySettings().Height.y);
 					}
 
 					updateMaterial();
@@ -170,7 +213,8 @@
 			}
 		}
 
-		for(std::vector<Lightning*>::iterator it = mLightnings.begin(); it != mLightnings.end();)
+    for (std::vector<Lightning*>::iterator it = mLightnings.begin();
+         it != mLightnings.end();)
 		{
 			if ((*it)->isFinished())
 			{
@@ -180,7 +224,8 @@
 				it = mLightnings.erase(it);
 
 				// Remove the associated scene node
-				for(std::vector<Ogre::SceneNode*>::iterator it2 = mSceneNodes.begin(); it2 != mSceneNodes.end(); it2++)
+        for (std::vector<Ogre::SceneNode*>::iterator it2 = mSceneNodes.begin();
+             it2 != mSceneNodes.end(); it2++)
 				{
 					if ((*it2) == sn)
 					{
@@ -198,21 +243,24 @@
 		}
 	}
 
-	Lightning* LightningManager::addLightning(const Ogre::Vector3& p, const Ogre::Vector3& d, const Ogre::Real l, const Ogre::uint32& div)
+  Lightning* LightningManager::addLightning(const Ogre::Vector3& p,
+      const Ogre::Vector3& d,  const Ogre::Real l,  const Ogre::uint32& div)
 	{
 		if (!mCreated || mLightnings.size() == 3)
 		{
 			return static_cast<Lightning*>(NULL);
 		}
 
-		Ogre::SceneNode* sn = mVClouds->getSceneManager()->getRootSceneNode()->createChildSceneNode();
+    Ogre::SceneNode* sn = mVClouds->getSceneManager()->getRootSceneNode()->
+      createChildSceneNode();
 		sn->setPosition(p);
 
-		Lightning* lightning = new Lightning(mVClouds->getSceneManager(), sn, Ogre::Vector3(0,0,0), d, l, div, 3, mLightningTimeMultiplier, mVClouds->getGeometrySettings().Radius/9500);
+    Lightning* lightning = new Lightning(mVClouds->getSceneManager(),
+        sn,  Ogre::Vector3(0,  0,  0),  d,  l,  div,  3,
+        mLightningTimeMultiplier,  mVClouds->getGeometrySettings().Radius/9500);
 		lightning->create();
-		lightning->_updateRenderQueueGroup(
-			mVClouds->getGeometryManager()->_getCurrentDistance().y < mVClouds->getGeometryManager()->getHeight().y/2 ?
-			mVClouds->getRenderQueueGroups().vcloudsLightningsUnder : mVClouds->getRenderQueueGroups().vcloudsLightningsOver);
+    lightning->_updateRenderQueueGroup(mVClouds->
+        getRenderQueueGroups().vcloudsLightnings);
 		lightning->getBillboardSet()->setVisible(mVClouds->isVisible());
 
 		mSceneNodes.push_back(sn);
@@ -234,16 +282,21 @@
 		{
 			if (k < mLightnings.size())
 			{
-				pos = mVClouds->getGeometryManager()->getSceneNode()->_getFullTransform().inverseAffine() * mSceneNodes.at(k)->_getDerivedPosition();
+        pos = mVClouds->getGeometryManager()->getSceneNode()->
+          _getFullTransform().inverseAffine() *
+          mSceneNodes.at(k)->_getDerivedPosition();
 
 				mVolCloudsLightningMaterial->
-					getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uLightning" + Ogre::StringConverter::toString(k), 
-						Ogre::Vector4(pos.x, pos.y, pos.z, mLightnings.at(k)->getIntensity()));
+          getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+          setNamedConstant("uLightning" + Ogre::StringConverter::toString(k),
+              Ogre::Vector4(pos.x,  pos.y,
+                pos.z,  mLightnings.at(k)->getIntensity()));
 			}
 			else
 			{
 				mVolCloudsLightningMaterial->
-					getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uLightning" + Ogre::StringConverter::toString(k), 
+          getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+          setNamedConstant("uLightning" + Ogre::StringConverter::toString(k),
 						Ogre::Vector4(0,0,0,0));
 			}
 		}
@@ -258,16 +311,19 @@
 			return;
 		}
 
-		mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+    mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->
+      getFragmentProgramParameters()
 			->setNamedConstant("uLightningColor", mLightningColor);
 
-		mLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+    mLightningMaterial->getTechnique(0)->getPass(0)->
+      getFragmentProgramParameters()
 			->setNamedConstant("uColor", mLightningColor);
 	}
 
 	void LightningManager::removeListener(Listener* listener)
 	{
-		for(std::vector<Listener*>::iterator it = mListeners.begin(); it != mListeners.end(); it++)
+    for (std::vector<Listener*>::iterator it = mListeners.begin();
+        it != mListeners.end(); it++)
 		{
 			if ((*it) == listener)
 			{
@@ -285,7 +341,8 @@
 		{
 			if (mEnabled)
 			{
-				mVClouds->getGeometryManager()->_setMaterialName("SkyX_VolClouds_Lightning");
+        mVClouds->getGeometryManager()->_setMaterialName(
+            "SkyX_VolClouds_Lightning");
 			}
 			else
 			{
@@ -294,11 +351,12 @@
 		}
 	}
 
-	void LightningManager::_updateRenderQueueGroup(const Ogre::uint8& rqg)
+  void LightningManager::_updateRenderQueueGroup(const Ogre::uint8& /*rqg*/)
 	{
 		for(Ogre::uint32 k = 0; k < mLightnings.size(); k++)
 		{	
-			mLightnings.at(k)->_updateRenderQueueGroup(rqg);
+      mLightnings.at(k)->_updateRenderQueueGroup(mVClouds->
+          getRenderQueueGroups().vcloudsLightnings);
 		}
 	}
 
@@ -309,5 +367,4 @@
 			mLightnings.at(k)->getBillboardSet()->setVisible(v);
 		}
 	}
-
 }}
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VClouds/VClouds.cpp	2012-12-27 01:39:48.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VClouds/VClouds.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -21,6 +21,7 @@
 --------------------------------------------------------------------------------
 */
 
+#include <vector>
 #include "VClouds/VClouds.h"
 
 #include "SkyX.h"
@@ -33,7 +34,8 @@
 		, mCreated(false)
 		, mGeometrySettings(GeometrySettings())
 		, mDistanceFallingParams(Ogre::Vector2(1,-1))
-		, mRenderQueueGroups(RenderQueueGroups(Ogre::RENDER_QUEUE_MAIN, Ogre::RENDER_QUEUE_9, Ogre::RENDER_QUEUE_4))
+    , mRenderQueueGroups(RenderQueueGroups(
+          Ogre::RENDER_QUEUE_MAIN, Ogre::RENDER_QUEUE_9))
 		, mWindDirection(Ogre::Degree(0))
 		, mWindSpeed(80.0f)
 		, mWheater(Ogre::Vector2(0.5f, 1.0f))
@@ -59,22 +61,22 @@
 	VClouds::~VClouds()
 	{
 		remove();
-
-		delete mDataManager;
-		delete mGeometryManager;
-		delete mLightningManager;
 	}
 
 	void VClouds::create()
 	{
 		remove();
 
-		mVolCloudsMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds"));
-		mVolCloudsLightningMaterial = static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds_Lightning"));
+  mVolCloudsMaterial = static_cast<Ogre::MaterialPtr>(
+      Ogre::MaterialManager::getSingleton().getByName("SkyX_VolClouds"));
+  mVolCloudsLightningMaterial = static_cast<Ogre::MaterialPtr>(
+      Ogre::MaterialManager::getSingleton().getByName(
+        "SkyX_VolClouds_Lightning"));
 
 		if (mVolCloudsMaterial.isNull() || mVolCloudsLightningMaterial.isNull())
 		{
-			SkyXLOG("Error while creating SkyX::VClouds::VClouds, materials are not found");
+    SkyXLOG("Error while creating SkyX::VClouds::VClouds,"
+            "materials are not found");
 			return;
 		}
 
@@ -82,15 +84,19 @@
 		mDataManager->create(128,128,20);
 
 		// Geometry manager
-		mGeometryManager->create(mGeometrySettings.Height, mGeometrySettings.Radius, mGeometrySettings.Alpha, 
-			mGeometrySettings.Beta, mGeometrySettings.NumberOfBlocks, mGeometrySettings.Na, mGeometrySettings.Nb, mGeometrySettings.Nc);
+  mGeometryManager->create(mGeometrySettings.Height,
+      mGeometrySettings.Radius, mGeometrySettings.Alpha,
+      mGeometrySettings.Beta, mGeometrySettings.NumberOfBlocks,
+      mGeometrySettings.Na, mGeometrySettings.Nb, mGeometrySettings.Nc);
 
 		mGeometryManager->getSceneNode()->setVisible(mVisible);
 
 		mVolCloudsMaterial
-			->getTechnique(0)->getPass(0)->getVertexProgramParameters()->setNamedConstant("uRadius", mGeometrySettings.Radius);
+    ->getTechnique(0)->getPass(0)->getVertexProgramParameters()->
+    setNamedConstant("uRadius", mGeometrySettings.Radius);
 		mVolCloudsLightningMaterial->
-			getTechnique(0)->getPass(0)->getVertexProgramParameters()->setNamedConstant("uRadius", mGeometrySettings.Radius);
+    getTechnique(0)->getPass(0)->getVertexProgramParameters()->
+    setNamedConstant("uRadius", mGeometrySettings.Radius);
 
 		// Lightning manager
 		mLightningManager->create();
@@ -158,20 +164,25 @@
 		if (mLightningManager->isEnabled())
 		{
 			mVolCloudsLightningMaterial->
-				getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uInterpolation", mDataManager->_getInterpolation());
+      getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+      setNamedConstant("uInterpolation", mDataManager->_getInterpolation());
 			mVolCloudsLightningMaterial->
-				getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uSunDirection", -mSunDirection);
+      getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+      setNamedConstant("uSunDirection", -mSunDirection);
 		}
 		else
 		{
 			mVolCloudsMaterial->
-				getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uInterpolation", mDataManager->_getInterpolation());
+      getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+      setNamedConstant("uInterpolation", mDataManager->_getInterpolation());
 			mVolCloudsMaterial->
-				getTechnique(0)->getPass(0)->getFragmentProgramParameters()->setNamedConstant("uSunDirection", -mSunDirection);
+      getTechnique(0)->getPass(0)->getFragmentProgramParameters()->
+      setNamedConstant("uSunDirection", -mSunDirection);
 		}
 	}
 
-	void VClouds::notifyCameraRender(Ogre::Camera* c, const Ogre::Real& timeSinceLastCameraFrame)
+void VClouds::notifyCameraRender(Ogre::Camera* c,
+    const Ogre::Real& timeSinceLastCameraFrame)
 	{
 		if (!mCreated)
 		{
@@ -194,14 +205,12 @@
 		if (!isRegistered)
 		{
 			mCamerasData.push_back(CameraData(c));
-			SkyXLOG("VClouds warning: unregistered camera registered, manual unregistering is needed before camera destruction");
+    SkyXLOG("VClouds warning: unregistered camera registered, "
+            "manual unregistering is needed before camera destruction");
 		}
 
 		mGeometryManager->updateGeometry(c, timeSinceLastCameraFrame);
 		mLightningManager->updateMaterial();
-
-		mLightningManager->_updateRenderQueueGroup(mGeometryManager->_getCurrentDistance().y < mGeometryManager->getHeight().y/2 ?
-			mRenderQueueGroups.vcloudsLightningsUnder : mRenderQueueGroups.vcloudsLightningsOver);
 	}
 
 	void VClouds::registerCamera(Ogre::Camera* c)
@@ -219,7 +228,8 @@
 
 	void VClouds::unregisterCamera(Ogre::Camera* c)
 	{
-		for (std::vector<CameraData>::iterator it = mCamerasData.begin(); it != mCamerasData.end(); it++)
+  for (std::vector<CameraData>::iterator it = mCamerasData.begin();
+       it != mCamerasData.end(); it++)
 		{
 			if ((*it).camera == c)
 			{
@@ -242,6 +252,18 @@
 		mLightningManager->_setVisible(mVisible);
 	}
 
+void VClouds::setEnabled(bool _enabled)
+{
+  if (!mCreated)
+  {
+    return;
+  }
+
+  bool visible = _enabled ? mVisible : false;
+  mGeometryManager->getSceneNode()->setVisible(visible);
+  mLightningManager->_setVisible(visible);
+}
+
 	void VClouds::setRenderQueueGroups(const RenderQueueGroups& rqg)
 	{
 		mRenderQueueGroups = rqg;
@@ -252,6 +274,7 @@
 		}
 
 		mGeometryManager->_updateRenderQueueGroup(rqg.vclouds);
+  mLightningManager->_updateRenderQueueGroup(rqg.vcloudsLightnings);
 	}
 
 	void VClouds::setSunColor(const Ogre::Vector3& SunColor)
@@ -263,9 +286,11 @@
 			return;
 		}
 
-		mVolCloudsMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uSunColor", mSunColor);
-		mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uSunColor", mSunColor);
 	}
 
@@ -278,9 +303,11 @@
 			return;
 		}
 
-		mVolCloudsMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uAmbientColor", mAmbientColor);
-		mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uAmbientColor", mAmbientColor);
 	}
 
@@ -293,9 +320,11 @@
 			return;
 		}
 
-		mVolCloudsMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uLightResponse", mLightResponse);
-		mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uLightResponse", mLightResponse);
 	}
 
@@ -308,13 +337,17 @@
 			return;
 		}
 
-		mVolCloudsMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uAmbientFactors", mAmbientFactors);
-		mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->getFragmentProgramParameters()
+  mVolCloudsLightningMaterial->getTechnique(0)->getPass(0)->
+    getFragmentProgramParameters()
 			->setNamedConstant("uAmbientFactors", mAmbientFactors);
 	}
 
-	void VClouds::setWheater(const float& Humidity, const float& AverageCloudsSize, const bool& DelayedResponse)
+void VClouds::setWheater(const float& Humidity,
+                         const float& AverageCloudsSize,
+                         const bool& DelayedResponse)
 	{
 		mWheater = Ogre::Vector2(Humidity, AverageCloudsSize);
 		mDelayedResponse = DelayedResponse;
@@ -326,5 +359,4 @@
 
 		mDataManager->setWheater(mWheater.x, mWheater.y, mDelayedResponse);
 	}
-
 }}
\ No newline at end of file
only in patch2:
unchanged:
--- SkyX-0.4/SkyX/Source/VCloudsManager.cpp	2012-12-27 00:33:28.000000000 -0500
+++ gazebo-1.9.0/gazebo/rendering/skyx/src/VCloudsManager.cpp	2013-07-23 19:51:21.000000000 -0400
@@ -38,27 +38,46 @@
 	{
 		mVClouds = new VClouds::VClouds(mSkyX->getSceneManager());
 		mVClouds->setRenderQueueGroups(
-			VClouds::VClouds::RenderQueueGroups(mSkyX->getRenderQueueGroups().vclouds, mSkyX->getRenderQueueGroups().vcloudsLightningsUnder, mSkyX->getRenderQueueGroups().vcloudsLightningsOver));
+      VClouds::VClouds::RenderQueueGroups(
+        mSkyX->getRenderQueueGroups().vclouds,
+        mSkyX->getRenderQueueGroups().vcloudsLightnings));
 
 		mAmbientGradient = ColorGradient();
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.9f, 1.0f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.7,0.7,0.65), 0.625f)); 
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.55,0.4)*0.5, 0.5625f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.55,0.4)*0.25, 0.475f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.45,0.3)*0.2, 0.4f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.3)*0.2, 0.325f));
-		mAmbientGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.2,0.2,0.3)*0.15, 0));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.9f, 1.0f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.7, 0.7, 0.65), 0.625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.55, 0.4)*0.5, 0.5625f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.55, 0.4)*0.25, 0.475f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.45, 0.3)*0.2, 0.4f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.3)*0.2, 0.325f));
+    mAmbientGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.2, 0.2, 0.3)*0.15, 0));
 
 		mSunGradient = ColorGradient();
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.9f, 1.0f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(1,1,1)*0.8, 0.75f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.8,0.75,0.55)*1.3, 0.5625f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*1.5, 0.5f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.6, 0.4725f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.6,0.5,0.2)*0.4, 0.45f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.0,0.0,0.0), 0.4125f)); // Sun-Moon threshold
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.25,0.25,0.25), 0.25f));
-		mSunGradient.addCFrame(ColorGradient::ColorFrame(Ogre::Vector3(0.4,0.4,0.4), 0.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.9f, 1.0f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(1, 1, 1)*0.8, 0.75f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.8, 0.75, 0.55)*1.3, 0.5625f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*1.5, 0.5f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.6, 0.4725f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.6, 0.5, 0.2)*0.4, 0.45f));
+    // Sun-Moon threshold
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.0, 0.0, 0.0), 0.4125f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.25, 0.25, 0.25), 0.25f));
+    mSunGradient.addCFrame(
+        ColorGradient::ColorFrame(Ogre::Vector3(0.4, 0.4, 0.4), 0.0f));
 	}
 
 	VCloudsManager::~VCloudsManager()
@@ -75,11 +94,15 @@
 			return;
 		}
 
-		Ogre::Real selectedRadius = radius < 0 ? mVClouds->getGeometrySettings().Radius : radius;
+    Ogre::Real selectedRadius = radius < 0 ?
+      mVClouds->getGeometrySettings().Radius : radius;
 
-		// Use default options if the user haven't set any specific Height parameters
-		Ogre::Vector2 defaultheight = Ogre::Vector2(selectedRadius*0.025f, selectedRadius*0.1f); 
-		Ogre::Vector2 height = (mHeight.x == -1 || mHeight.y == -1) ? defaultheight : mHeight;
+    // Use default options if the user haven't set any specific Height
+    // parameters
+    Ogre::Vector2 defaultheight = Ogre::Vector2(selectedRadius*0.025f,
+        selectedRadius*0.1f);
+    Ogre::Vector2 height = (equal(mHeight.x, -1.0f) ||
+                            equal(mHeight.y, -1.0f)) ? defaultheight : mHeight;
 
 		_setLightParameters();
 		mVClouds->create(height, selectedRadius);
@@ -130,14 +153,14 @@
 		Ogre::Vector3 SunDir = -mSkyX->getController()->getSunDirection();
 
 		// Moon
-		if (SunDir.y > 0.175f)
+    if (SunDir.z > 0.175f)
 		{
 			SunDir = -mSkyX->getController()->getMoonDirection();
 		}
 
 		mVClouds->setSunDirection(SunDir);
 
-		float point = (mSkyX->getController()->getSunDirection().y + 1.0f) / 2.0f;
+    float point = (mSkyX->getController()->getSunDirection().z + 1.0f) / 2.0f;
 
 		mVClouds->setAmbientColor(mAmbientGradient.getColor(point));
 		mVClouds->setSunColor(mSunGradient.getColor(point));
